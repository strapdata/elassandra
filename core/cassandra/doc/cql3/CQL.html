<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>CQL</title></head><body><p><link rel="StyleSheet" href="CQL.css" type="text/css" media="screen"></p><h1 id="CassandraQueryLanguageCQLv3.4.0">Cassandra Query Language (CQL) v3.4.0</h1><span id="tableOfContents"><ol style="list-style: none;"><li><a href="CQL.html#CassandraQueryLanguageCQLv3.4.0">Cassandra Query Language (CQL) v3.4.0</a><ol style="list-style: none;"><li><a href="CQL.html#CQLSyntax">CQL Syntax</a><ol style="list-style: none;"><li><a href="CQL.html#Preamble">Preamble</a></li><li><a href="CQL.html#Conventions">Conventions</a></li><li><a href="CQL.html#identifiers">Identifiers and keywords</a></li><li><a href="CQL.html#constants">Constants</a></li><li><a href="CQL.html#Comments">Comments</a></li><li><a href="CQL.html#statements">Statements</a></li><li><a href="CQL.html#preparedStatement">Prepared Statement</a></li></ol></li><li><a href="CQL.html#dataDefinition">Data Definition</a><ol style="list-style: none;"><li><a href="CQL.html#createKeyspaceStmt">CREATE KEYSPACE</a></li><li><a href="CQL.html#useStmt">USE</a></li><li><a href="CQL.html#alterKeyspaceStmt">ALTER KEYSPACE</a></li><li><a href="CQL.html#dropKeyspaceStmt">DROP KEYSPACE</a></li><li><a href="CQL.html#createTableStmt">CREATE TABLE</a></li><li><a href="CQL.html#alterTableStmt">ALTER TABLE</a></li><li><a href="CQL.html#dropTableStmt">DROP TABLE</a></li><li><a href="CQL.html#truncateStmt">TRUNCATE</a></li><li><a href="CQL.html#createIndexStmt">CREATE INDEX</a></li><li><a href="CQL.html#dropIndexStmt">DROP INDEX</a></li><li><a href="CQL.html#createMVStmt">CREATE MATERIALIZED VIEW</a></li><li><a href="CQL.html#alterMVStmt">ALTER MATERIALIZED VIEW</a></li><li><a href="CQL.html#dropMVStmt">DROP MATERIALIZED VIEW</a></li><li><a href="CQL.html#createTypeStmt">CREATE TYPE</a></li><li><a href="CQL.html#alterTypeStmt">ALTER TYPE</a></li><li><a href="CQL.html#dropTypeStmt">DROP TYPE</a></li><li><a href="CQL.html#createTriggerStmt">CREATE TRIGGER</a></li><li><a href="CQL.html#dropTriggerStmt">DROP TRIGGER</a></li><li><a href="CQL.html#createFunctionStmt">CREATE FUNCTION</a></li><li><a href="CQL.html#dropFunctionStmt">DROP FUNCTION</a></li><li><a href="CQL.html#createAggregateStmt">CREATE AGGREGATE</a></li><li><a href="CQL.html#dropAggregateStmt">DROP AGGREGATE</a></li></ol></li><li><a href="CQL.html#dataManipulation">Data Manipulation</a><ol style="list-style: none;"><li><a href="CQL.html#insertStmt">INSERT</a></li><li><a href="CQL.html#updateStmt">UPDATE</a></li><li><a href="CQL.html#deleteStmt">DELETE</a></li><li><a href="CQL.html#batchStmt">BATCH</a></li></ol></li><li><a href="CQL.html#queries">Queries</a><ol style="list-style: none;"><li><a href="CQL.html#selectStmt">SELECT</a></li></ol></li><li><a href="CQL.html#databaseRoles">Database Roles</a><ol style="list-style: none;"><li><a href="CQL.html#createRoleStmt">CREATE ROLE</a></li><li><a href="CQL.html#alterRoleStmt">ALTER ROLE</a></li><li><a href="CQL.html#dropRoleStmt">DROP ROLE</a></li><li><a href="CQL.html#grantRoleStmt">GRANT ROLE</a></li><li><a href="CQL.html#revokeRoleStmt">REVOKE ROLE</a></li><li><a href="CQL.html#createUserStmt">CREATE USER </a></li><li><a href="CQL.html#alterUserStmt">ALTER USER </a></li><li><a href="CQL.html#dropUserStmt">DROP USER </a></li><li><a href="CQL.html#listUsersStmt">LIST USERS</a></li></ol></li><li><a href="CQL.html#dataControl">Data Control</a><ol style="list-style: none;"><li><a href="CQL.html#permissions">Permissions </a></li><li><a href="CQL.html#grantPermissionsStmt">GRANT PERMISSION</a></li><li><a href="CQL.html#revokePermissionsStmt">REVOKE PERMISSION</a></li></ol></li><li><a href="CQL.html#types">Data Types</a><ol style="list-style: none;"><li><a href="CQL.html#usingtimestamps">Working with timestamps</a></li><li><a href="CQL.html#usingdates">Working with dates</a></li><li><a href="CQL.html#usingtime">Working with time</a></li><li><a href="CQL.html#counters">Counters</a></li><li><a href="CQL.html#collections">Working with collections</a></li></ol></li><li><a href="CQL.html#functions">Functions</a><ol style="list-style: none;"><li><a href="CQL.html#tokenFun">Token</a></li><li><a href="CQL.html#uuidFun">Uuid</a></li><li><a href="CQL.html#timeuuidFun">Timeuuid functions</a></li><li><a href="CQL.html#timeFun">Time conversion functions</a></li><li><a href="CQL.html#blobFun">Blob conversion functions</a></li></ol></li><li><a href="CQL.html#aggregates">Aggregates</a><ol style="list-style: none;"><li><a href="CQL.html#countFct">Count</a></li><li><a href="CQL.html#maxMinFcts">Max and Min</a></li><li><a href="CQL.html#sumFct">Sum</a></li><li><a href="CQL.html#avgFct">Avg</a></li></ol></li><li><a href="CQL.html#udfs">User-Defined Functions</a></li><li><a href="CQL.html#udas">User-Defined Aggregates</a></li><li><a href="CQL.html#json">JSON Support</a><ol style="list-style: none;"><li><a href="CQL.html#selectJson">SELECT JSON</a></li><li><a href="CQL.html#insertJson">INSERT JSON</a></li><li><a href="CQL.html#jsonEncoding">JSON Encoding of Cassandra Data Types</a></li><li><a href="CQL.html#fromJson">The fromJson() Function</a></li><li><a href="CQL.html#toJson">The toJson() Function</a></li></ol></li><li><a href="CQL.html#appendixA">Appendix A: CQL Keywords</a></li><li><a href="CQL.html#appendixB">Appendix B: CQL Reserved Types</a></li><li><a href="CQL.html#changes">Changes</a><ol style="list-style: none;"><li><a href="CQL.html#a3.4.0">3.4.0</a></li><li><a href="CQL.html#a3.3.1">3.3.1</a></li><li><a href="CQL.html#a3.3.0">3.3.0</a></li><li><a href="CQL.html#a3.2.0">3.2.0</a></li><li><a href="CQL.html#a3.1.7">3.1.7</a></li><li><a href="CQL.html#a3.1.6">3.1.6</a></li><li><a href="CQL.html#a3.1.5">3.1.5</a></li><li><a href="CQL.html#a3.1.4">3.1.4</a></li><li><a href="CQL.html#a3.1.3">3.1.3</a></li><li><a href="CQL.html#a3.1.2">3.1.2</a></li><li><a href="CQL.html#a3.1.1">3.1.1</a></li><li><a href="CQL.html#a3.1.0">3.1.0</a></li><li><a href="CQL.html#a3.0.5">3.0.5</a></li><li><a href="CQL.html#a3.0.4">3.0.4</a></li><li><a href="CQL.html#a3.0.3">3.0.3</a></li><li><a href="CQL.html#a3.0.2">3.0.2</a></li><li><a href="CQL.html#a3.0.1">3.0.1</a></li></ol></li><li><a href="CQL.html#Versioning">Versioning</a></li></ol></li></ol></span><h2 id="CQLSyntax">CQL Syntax</h2><h3 id="Preamble">Preamble</h3><p>This document describes the Cassandra Query Language (CQL) version 3. CQL v3 is not backward compatible with CQL v2 and differs from it in numerous ways. Note that this document describes the last version of the languages. However, the <a href="#changes">changes</a> section provides the diff between the different versions of CQL v3.</p><p>CQL v3 offers a model very close to SQL in the sense that data is put in <em>tables</em> containing <em>rows</em> of <em>columns</em>. For that reason, when used in this document, these terms (tables, rows and columns) have the same definition than they have in SQL. But please note that as such, they do <strong>not</strong> refer to the concept of rows and columns found in the internal implementation of Cassandra and in the thrift and CQL v2 API.</p><h3 id="Conventions">Conventions</h3><p>To aid in specifying the CQL syntax, we will use the following conventions in this document:</p><ul><li>Language rules will be given in a <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a> -like notation:</li></ul><pre class="syntax"><pre>&lt;start> ::= TERMINAL &lt;non-terminal1> &lt;non-terminal1>
</pre></pre><ul><li>Nonterminal symbols will have <code>&lt;angle brackets></code>.</li><li>As additional shortcut notations to BNF, we&#8217;ll use traditional regular expression&#8217;s symbols (<code>?</code>, <code>+</code> and <code>*</code>) to signify that a given symbol is optional and/or can be repeated. We&#8217;ll also allow parentheses to group symbols and the <code>[&lt;characters>]</code> notation to represent any one of <code>&lt;characters></code>.</li><li>The grammar is provided for documentation purposes and leave some minor details out. For instance, the last column definition in a <code>CREATE TABLE</code> statement is optional but supported if present even though the provided grammar in this document suggest it is not supported. </li><li>Sample code will be provided in a code block:</li></ul><pre class="sample"><pre>SELECT sample_usage FROM cql;
</pre></pre><ul><li>References to keywords or pieces of CQL code in running text will be shown in a <code>fixed-width font</code>.</li></ul><h3 id="identifiers">Identifiers and keywords</h3><p>The CQL language uses <em>identifiers</em> (or <em>names</em>) to identify tables, columns and other objects. An identifier is a token matching the regular expression <code>[a-zA-Z]</code><code>[a-zA-Z0-9_]</code><code>*</code>.</p><p>A number of such identifiers, like <code>SELECT</code> or <code>WITH</code>, are <em>keywords</em>. They have a fixed meaning for the language and most are reserved. The list of those keywords can be found in <a href="#appendixA">Appendix A</a>.</p><p>Identifiers and (unquoted) keywords are case insensitive. Thus <code>SELECT</code> is the same than <code>select</code> or <code>sElEcT</code>, and <code>myId</code> is the same than <code>myid</code> or <code>MYID</code> for instance. A convention often used (in particular by the samples of this documentation) is to use upper case for keywords and lower case for other identifiers.</p><p>There is a second kind of identifiers called <em>quoted identifiers</em> defined by enclosing an arbitrary sequence of characters in double-quotes(<code>"</code>). Quoted identifiers are never keywords. Thus <code>"select"</code> is not a reserved keyword and can be used to refer to a column, while <code>select</code> would raise a parse error. Also, contrarily to unquoted identifiers and keywords, quoted identifiers are case sensitive (<code>"My Quoted Id"</code> is <em>different</em> from <code>"my quoted id"</code>). A fully lowercase quoted identifier that matches <code>[a-zA-Z]</code><code>[a-zA-Z0-9_]</code><code>*</code> is equivalent to the unquoted identifier obtained by removing the double-quote (so <code>"myid"</code> is equivalent to <code>myid</code> and to <code>myId</code> but different from <code>"myId"</code>). Inside a quoted identifier, the double-quote character can be repeated to escape it, so <code>"foo "" bar"</code> is a valid identifier.</p><p><strong>Warning</strong>: <em>quoted identifiers</em> allows to declare columns with arbitrary names, and those can sometime clash with specific names used by the server. For instance, when using conditional update, the server will respond with a result-set containing a special result named <code>"[applied]"</code>. If you&#8217;ve declared a column with such a name, this could potentially confuse some tools and should be avoided. In general, unquoted identifiers should be preferred but if you use quoted identifiers, it is strongly advised to avoid any name enclosed by squared brackets (like <code>"[applied]"</code>) and any name that looks like a function call (like <code>"f(x)"</code>).</p><h3 id="constants">Constants</h3><p>CQL defines the following kind of <em>constants</em>: strings, integers, floats, booleans, uuids and blobs:</p><ul><li>A string constant is an arbitrary sequence of characters characters enclosed by single-quote(<code>'</code>). One can include a single-quote in a string by repeating it, e.g. <code>'It''s raining today'</code>. Those are not to be confused with quoted identifiers that use double-quotes.</li><li>An integer constant is defined by <code>'-'?[0-9]+</code>.</li><li>A float constant is defined by <code>'-'?[0-9]+('.'[0-9]*)?([eE][+-]?[0-9+])?</code>. On top of that, <code>NaN</code> and <code>Infinity</code> are also float constants.</li><li>A boolean constant is either <code>true</code> or <code>false</code> up to case-insensitivity (i.e. <code>True</code> is a valid boolean constant).</li><li>A <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a> constant is defined by <code>hex{8}-hex{4}-hex{4}-hex{4}-hex{12}</code> where <code>hex</code> is an hexadecimal character, e.g. <code>[0-9a-fA-F]</code> and <code>{4}</code> is the number of such characters.</li><li>A blob constant is an hexadecimal number defined by <code>0[xX](hex)+</code> where <code>hex</code> is an hexadecimal character, e.g. <code>[0-9a-fA-F]</code>.</li></ul><p>For how these constants are typed, see the <a href="#types">data types section</a>.</p><h3 id="Comments">Comments</h3><p>A comment in CQL is a line beginning by either double dashes (<code>--</code>) or double slash (<code>//</code>).</p><p>Multi-line comments are also supported through enclosure within <code>/*</code> and <code>*/</code> (but nesting is not supported).</p><pre class="sample"><pre>-- This is a comment
// This is a comment too
/* This is
   a multi-line comment */
</pre></pre><h3 id="statements">Statements</h3><p>CQL consists of statements. As in SQL, these statements can be divided in 3 categories:</p><ul><li>Data definition statements, that allow to set and change the way data is stored.</li><li>Data manipulation statements, that allow to change data</li><li>Queries, to look up data</li></ul><p>All statements end with a semicolon (<code>;</code>) but that semicolon can be omitted when dealing with a single statement. The supported statements are described in the following sections. When describing the grammar of said statements, we will reuse the non-terminal symbols defined below:</p><pre class="syntax"><pre>&lt;identifier> ::= any quoted or unquoted identifier, excluding reserved keywords
 &lt;tablename> ::= (&lt;identifier> '.')? &lt;identifier>

    &lt;string> ::= a string constant
   &lt;integer> ::= an integer constant
     &lt;float> ::= a float constant
    &lt;number> ::= &lt;integer> | &lt;float>
      &lt;uuid> ::= a uuid constant
   &lt;boolean> ::= a boolean constant
       &lt;hex> ::= a blob constant

  &lt;constant> ::= &lt;string>
               | &lt;number>
               | &lt;uuid>
               | &lt;boolean>
               | &lt;hex>
  &lt;variable> ::= '?'
               | ':' &lt;identifier>
      &lt;term> ::= &lt;constant>
               | &lt;collection-literal>
               | &lt;variable>
               | &lt;function> '(' (&lt;term> (',' &lt;term>)*)? ')'

  &lt;collection-literal> ::= &lt;map-literal>
                         | &lt;set-literal>
                         | &lt;list-literal>
         &lt;map-literal> ::= '{' ( &lt;term> ':' &lt;term> ( ',' &lt;term> ':' &lt;term> )* )? '}'
         &lt;set-literal> ::= '{' ( &lt;term> ( ',' &lt;term> )* )? '}'
        &lt;list-literal> ::= '[' ( &lt;term> ( ',' &lt;term> )* )? ']'

    &lt;function> ::= &lt;ident>

  &lt;properties> ::= &lt;property> (AND &lt;property>)*
    &lt;property> ::= &lt;identifier> '=' ( &lt;identifier> | &lt;constant> | &lt;map-literal> )
</pre></pre><p><br/>Please note that not every possible productions of the grammar above will be valid in practice. Most notably, <code>&lt;variable></code> and nested <code>&lt;collection-literal></code> are currently not allowed inside <code>&lt;collection-literal></code>.</p><p>A <code>&lt;variable></code> can be either anonymous (a question mark (<code>?</code>)) or named (an identifier preceded by <code>:</code>). Both declare a bind variables for <a href="#preparedStatement">prepared statements</a>. The only difference between an anymous and a named variable is that a named one will be easier to refer to (how exactly depends on the client driver used).</p><p>The <code>&lt;properties></code> production is use by statement that create and alter keyspaces and tables. Each <code>&lt;property></code> is either a <em>simple</em> one, in which case it just has a value, or a <em>map</em> one, in which case it&#8217;s value is a map grouping sub-options. The following will refer to one or the other as the <em>kind</em> (<em>simple</em> or <em>map</em>) of the property.</p><p>A <code>&lt;tablename></code> will be used to identify a table. This is an identifier representing the table name that can be preceded by a keyspace name. The keyspace name, if provided, allow to identify a table in another keyspace than the currently active one (the currently active keyspace is set through the <a href=":#useStmt"><tt>USE</tt></a> statement).</p><p>For supported <code>&lt;function></code>, see the section on <a href="#functions">functions</a>.</p><p>Strings can be either enclosed with single quotes or two dollar characters. The second syntax has been introduced to allow strings that contain single quotes. Typical candidates for such strings are source code fragments for user-defined functions.</p><p><i>Sample:</i></p><pre class="sample"><pre>  'some string value'

  $$double-dollar string can contain single ' quotes$$
</pre></pre><p></p><h3 id="preparedStatement">Prepared Statement</h3><p>CQL supports <em>prepared statements</em>. Prepared statement is an optimization that allows to parse a query only once but execute it multiple times with different concrete values.</p><p>In a statement, each time a column value is expected (in the data manipulation and query statements), a <code>&lt;variable></code> (see above) can be used instead. A statement with bind variables must then be <em>prepared</em>. Once it has been prepared, it can executed by providing concrete values for the bind variables. The exact procedure to prepare a statement and execute a prepared statement depends on the CQL driver used and is beyond the scope of this document.</p><p>In addition to providing column values, bind markers may be used to provide values for <code>LIMIT</code>, <code>TIMESTAMP</code>, and <code>TTL</code> clauses.  If anonymous bind markers are used, the names for the query parameters will be <code>[limit]</code>, <code>[timestamp]</code>, and <code>[ttl]</code>, respectively.</p><h2 id="dataDefinition">Data Definition</h2><h3 id="createKeyspaceStmt">CREATE KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-keyspace-stmt> ::= CREATE KEYSPACE (IF NOT EXISTS)? &lt;identifier> WITH &lt;properties>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE KEYSPACE Excelsior
           WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};

CREATE KEYSPACE Excalibur
           WITH replication = {'class': 'NetworkTopologyStrategy', 'DC1' : 1, 'DC2' : 3}
            AND durable_writes = false;
</pre></pre><p><br/>The <code>CREATE KEYSPACE</code> statement creates a new top-level <em>keyspace</em>. A keyspace is a namespace that defines a replication strategy and some options for a set of tables. Valid keyspaces names are identifiers composed exclusively of alphanumerical characters and whose length is lesser or equal to 32. Note that as identifiers, keyspace names are case insensitive: use a quoted identifier for case sensitive keyspace names.</p><p>The supported <code>&lt;properties></code> for <code>CREATE KEYSPACE</code> are:</p><table><tr><th>name          </th><th>kind   </th><th>mandatory </th><th>default </th><th>description</th></tr><tr><td><code>replication</code>    </td><td><em>map</em>    </td><td>yes         </td><td>          </td><td>The replication strategy and options to use for the keyspace. </td></tr><tr><td><code>durable_writes</code> </td><td><em>simple</em> </td><td>no          </td><td>true      </td><td>Whether to use the commit log for updates on this keyspace (disable this option at your own risk!). </td></tr></table><p>The <code>replication</code> <code>&lt;property></code> is mandatory. It must at least contains the <code>'class'</code> sub-option which defines the replication strategy class to use. The rest of the sub-options depends on that replication strategy class. By default, Cassandra support the following <code>'class'</code>:</p><ul><li><code>'SimpleStrategy'</code>: A simple strategy that defines a simple replication factor for the whole cluster. The only sub-options supported is <code>'replication_factor'</code> to define that replication factor and is mandatory.</li><li><code>'NetworkTopologyStrategy'</code>: A replication strategy that allows to set the replication factor independently for each data-center. The rest of the sub-options are key-value pairs where each time the key is the name of a datacenter and the value the replication factor for that data-center.</li><li><code>'OldNetworkTopologyStrategy'</code>: A legacy replication strategy. You should avoid this strategy for new keyspaces and prefer <code>'NetworkTopologyStrategy'</code>.</li></ul><p>Attempting to create an already existing keyspace will return an error unless the <code>IF NOT EXISTS</code> option is used. If it is used, the statement will be a no-op if the keyspace already exists.</p><h3 id="useStmt">USE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;use-stmt> ::= USE &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>USE myApp;
</pre></pre><p>The <code>USE</code> statement takes an existing keyspace name as argument and set it as the per-connection current working keyspace. All subsequent keyspace-specific actions will be performed in the context of the selected keyspace, unless <a href="#statements">otherwise specified</a>, until another USE statement is issued or the connection terminates.</p><h3 id="alterKeyspaceStmt">ALTER KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-keyspace-stmt> ::= ALTER KEYSPACE &lt;identifier> WITH &lt;properties>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>ALTER KEYSPACE Excelsior
          WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 4};

</pre></pre><p><br/>The <code>ALTER KEYSPACE</code> statement alters the properties of an existing keyspace. The supported <code>&lt;properties></code> are the same as for the <a href="#createKeyspaceStmt"><code>CREATE KEYSPACE</code></a> statement.</p><h3 id="dropKeyspaceStmt">DROP KEYSPACE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-keyspace-stmt> ::= DROP KEYSPACE ( IF EXISTS )? &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP KEYSPACE myApp;
</pre></pre><p>A <code>DROP KEYSPACE</code> statement results in the immediate, irreversible removal of an existing keyspace, including all column families in it, and all data contained in those column families.</p><p>If the keyspace does not exists, the statement will return an error, unless <code>IF EXISTS</code> is used in which case the operation is a no-op.</p><h3 id="createTableStmt">CREATE TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-table-stmt> ::= CREATE ( TABLE | COLUMNFAMILY ) ( IF NOT EXISTS )? &lt;tablename>
                          '(' &lt;column-definition> ( ',' &lt;column-definition> )* ')'
                          ( WITH &lt;option> ( AND &lt;option>)* )?

&lt;column-definition> ::= &lt;identifier> &lt;type> ( STATIC )? ( PRIMARY KEY )?
                      | PRIMARY KEY '(' &lt;partition-key> ( ',' &lt;identifier> )* ')'

&lt;partition-key> ::= &lt;identifier>
                  | '(' &lt;identifier> (',' &lt;identifier> )* ')'

&lt;option> ::= &lt;property>
           | COMPACT STORAGE
           | CLUSTERING ORDER
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE TABLE monkeySpecies (
    species text PRIMARY KEY,
    common_name text,
    population varint,
    average_size int
) WITH comment='Important biological records'
   AND read_repair_chance = 1.0;

CREATE TABLE timeline (
    userid uuid,
    posted_month int,
    posted_time uuid,
    body text,
    posted_by text,
    PRIMARY KEY (userid, posted_month, posted_time)
) WITH compaction = { 'class' : 'LeveledCompactionStrategy' };
</pre></pre><p><br/>The <code>CREATE TABLE</code> statement creates a new table. Each such table is a set of <em>rows</em> (usually representing related entities) for which it defines a number of properties. A table is defined by a <a href="#createTableName">name</a>, it defines the <a href="#createTableColumn"><it>columns</it></a> composing rows of the table and have a number of <a href="#createTableOptions">options</a>. Note that the <code>CREATE COLUMNFAMILY</code> syntax is supported as an alias for <code>CREATE TABLE</code> (for historical reasons).</p><p>Attempting to create an already existing table will return an error unless the <code>IF NOT EXISTS</code> option is used. If it is used, the statement will be a no-op if the table already exists.</p><h4 id="createTableName"><code>&lt;tablename></code></h4><p>Valid table names are the same as valid <a href="#createKeyspaceStmt">keyspace names</a> (up to 32 characters long alphanumerical identifiers). If the table name is provided alone, the table is created within the current keyspace (see <a href="#useStmt"><tt>USE</tt></a>), but if it is prefixed by an existing keyspace name (see <a href="#statements"><code>&lt;tablename></code></a> grammar), it is created in the specified keyspace (but does <strong>not</strong> change the current keyspace).</p><h4 id="createTableColumn"><code>&lt;column-definition></code></h4><p>A <code>CREATE TABLE</code> statement defines the columns that rows of the table can have. A <em>column</em> is defined by its name (an identifier) and its type (see the <a href="#types">data types</a> section for more details on allowed types and their properties).</p><p>Within a table, a row is uniquely identified by its <code>PRIMARY KEY</code> (or more simply the key), and hence all table definitions <strong>must</strong> define a PRIMARY KEY (and only one). A <code>PRIMARY KEY</code> is composed of one or more of the columns defined in the table. If the <code>PRIMARY KEY</code> is only one column, this can be specified directly after the column definition. Otherwise, it must be specified by following <code>PRIMARY KEY</code> by the comma-separated list of column names composing the key within parenthesis. Note that:</p><pre class="sample"><pre>CREATE TABLE t (
    k int PRIMARY KEY,
    other text
)
</pre></pre><p>is equivalent to</p><pre class="sample"><pre>CREATE TABLE t (
    k int,
    other text,
    PRIMARY KEY (k)
)
</pre></pre><h4 id="createTablepartitionClustering">Partition key and clustering columns</h4><p>In CQL, the order in which columns are defined for the <code>PRIMARY KEY</code> matters. The first column of the key is called the <i>partition key</i>. It has the property that all the rows sharing the same partition key (even across table in fact) are stored on the same physical node. Also, insertion/update/deletion on rows sharing the same partition key for a given table are performed <i>atomically</i> and in <i>isolation</i>. Note that it is possible to have a composite partition key, i.e. a partition key formed of multiple columns, using an extra set of parentheses to define which columns forms the partition key.</p><p>The remaining columns of the <code>PRIMARY KEY</code> definition, if any, are called __clustering columns. On a given physical node, rows for a given partition key are stored in the order induced by the clustering columns, making the retrieval of rows in that clustering order particularly efficient (see <a href="#selectStmt"><tt>SELECT</tt></a>).</p><h4 id="createTableStatic"><code>STATIC</code> columns</h4><p>Some columns can be declared as <code>STATIC</code> in a table definition. A column that is static will be &#171;shared&#187; by all the rows belonging to the same partition (having the same partition key). For instance, in:</p><pre class="sample"><pre>CREATE TABLE test (
    pk int,
    t int,
    v text,
    s text static,
    PRIMARY KEY (pk, t)
);
INSERT INTO test(pk, t, v, s) VALUES (0, 0, 'val0', 'static0');
INSERT INTO test(pk, t, v, s) VALUES (0, 1, 'val1', 'static1');
SELECT * FROM test WHERE pk=0 AND t=0;
</pre></pre><p>the last query will return <code>'static1'</code> as value for <code>s</code>, since <code>s</code> is static and thus the 2nd insertion modified this &#171;shared&#187; value. Note however that static columns are only static within a given partition, and if in the example above both rows where from different partitions (i.e. if they had different value for <code>pk</code>), then the 2nd insertion would not have modified the value of <code>s</code> for the first row.</p><p>A few restrictions applies to when static columns are allowed:</p><ul><li>tables with the <code>COMPACT STORAGE</code> option (see below) cannot have them</li><li>a table without clustering columns cannot have static columns (in a table without clustering columns, every partition has only one row, and so every column is inherently static).</li><li>only non <code>PRIMARY KEY</code> columns can be static</li></ul><h4 id="createTableOptions"><code>&lt;option></code></h4><p>The <code>CREATE TABLE</code> statement supports a number of options that controls the configuration of a new table. These options can be specified after the <code>WITH</code> keyword.</p><p>The first of these option is <code>COMPACT STORAGE</code>. This option is mainly targeted towards backward compatibility for definitions created before CQL3 (see <a href="http://www.datastax.com/dev/blog/thrift-to-cql3">www.datastax.com/dev/blog/thrift-to-cql3</a> for more details).  The option also provides a slightly more compact layout of data on disk but at the price of diminished flexibility and extensibility for the table.  Most notably, <code>COMPACT STORAGE</code> tables cannot have collections nor static columns and a <code>COMPACT STORAGE</code> table with at least one clustering column supports exactly one (as in not 0 nor more than 1) column not part of the <code>PRIMARY KEY</code> definition (which imply in particular that you cannot add nor remove columns after creation). For those reasons, <code>COMPACT STORAGE</code> is not recommended outside of the backward compatibility reason evoked above.</p><p>Another option is <code>CLUSTERING ORDER</code>. It allows to define the ordering of rows on disk. It takes the list of the clustering column names with, for each of them, the on-disk order (Ascending or descending). Note that this option affects <a href="#selectOrderBy">what <code>ORDER BY</code> are allowed during <code>SELECT</code></a>.</p><p>Table creation supports the following other <code>&lt;property></code>:</p><table><tr><th>option                    </th><th>kind   </th><th>default   </th><th>description</th></tr><tr><td><code>comment</code>                    </td><td><em>simple</em> </td><td>none        </td><td>A free-form, human-readable comment.</td></tr><tr><td><code>read_repair_chance</code>         </td><td><em>simple</em> </td><td>0.1         </td><td>The probability with which to query extra nodes (e.g. more nodes than required by the consistency level) for the purpose of read repairs.</td></tr><tr><td><code>dclocal_read_repair_chance</code> </td><td><em>simple</em> </td><td>0           </td><td>The probability with which to query extra nodes (e.g. more nodes than required by the consistency level) belonging to the same data center than the read coordinator for the purpose of read repairs.</td></tr><tr><td><code>gc_grace_seconds</code>           </td><td><em>simple</em> </td><td>864000      </td><td>Time to wait before garbage collecting tombstones (deletion markers).</td></tr><tr><td><code>bloom_filter_fp_chance</code>     </td><td><em>simple</em> </td><td>0.00075     </td><td>The target probability of false positive of the sstable bloom filters. Said bloom filters will be sized to provide the provided probability (thus lowering this value impact the size of bloom filters in-memory and on-disk)</td></tr><tr><td><code>default_time_to_live</code>       </td><td><em>simple</em> </td><td>0           </td><td>The default expiration time (&#171;TTL&#187;) in seconds for a table.</td></tr><tr><td><code>compaction</code>                 </td><td><em>map</em>    </td><td><em>see below</em> </td><td>Compaction options, see <a href="#compactionOptions">below</a>.</td></tr><tr><td><code>compression</code>                </td><td><em>map</em>    </td><td><em>see below</em> </td><td>Compression options, see <a href="#compressionOptions">below</a>.</td></tr><tr><td><code>caching</code>                    </td><td><em>map</em>    </td><td><em>see below</em> </td><td>Caching options, see <a href="#cachingOptions">below</a>.</td></tr></table><h4 id="compactionOptions">Compaction options</h4><p>The <code>compaction</code> property must at least define the <code>'class'</code> sub-option, that defines the compaction strategy class to use. The default supported class are <code>'SizeTieredCompactionStrategy'</code>, <code>'LeveledCompactionStrategy'</code>, <code>'DateTieredCompactionStrategy'</code> and <code>'TimeWindowCompactionStrategy'</code>. Custom strategy can be provided by specifying the full class name as a <a href="#constants">string constant</a>. The rest of the sub-options depends on the chosen class. The sub-options supported by the default classes are:</p><table><tr><th>option                         </th><th>supported compaction strategy </th><th>default    </th><th>description </th></tr><tr><td><code>enabled</code>                        </td><td><em>all</em>                           </td><td>true         </td><td>A boolean denoting whether compaction should be enabled or not.</td></tr><tr><td><code>tombstone_threshold</code>            </td><td><em>all</em>                           </td><td>0.2          </td><td>A ratio such that if a sstable has more than this ratio of gcable tombstones over all contained columns, the sstable will be compacted (with no other sstables) for the purpose of purging those tombstones. </td></tr><tr><td><code>tombstone_compaction_interval</code>  </td><td><em>all</em>                           </td><td>1 day        </td><td>The minimum time to wait after an sstable creation time before considering it for &#171;tombstone compaction&#187;, where &#171;tombstone compaction&#187; is the compaction triggered if the sstable has more gcable tombstones than <code>tombstone_threshold</code>. </td></tr><tr><td><code>unchecked_tombstone_compaction</code> </td><td><em>all</em>                           </td><td>false        </td><td>Setting this to true enables more aggressive tombstone compactions &#8211; single sstable tombstone compactions will run without checking how likely it is that they will be successful. </td></tr><tr><td><code>min_sstable_size</code>               </td><td>SizeTieredCompactionStrategy    </td><td>50MB         </td><td>The size tiered strategy groups SSTables to compact in buckets. A bucket groups SSTables that differs from less than 50% in size.  However, for small sizes, this would result in a bucketing that is too fine grained. <code>min_sstable_size</code> defines a size threshold (in bytes) below which all SSTables belong to one unique bucket</td></tr><tr><td><code>min_threshold</code>                  </td><td>SizeTieredCompactionStrategy    </td><td>4            </td><td>Minimum number of SSTables needed to start a minor compaction.</td></tr><tr><td><code>max_threshold</code>                  </td><td>SizeTieredCompactionStrategy    </td><td>32           </td><td>Maximum number of SSTables processed by one minor compaction.</td></tr><tr><td><code>bucket_low</code>                     </td><td>SizeTieredCompactionStrategy    </td><td>0.5          </td><td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%)</td></tr><tr><td><code>bucket_high</code>                    </td><td>SizeTieredCompactionStrategy    </td><td>1.5          </td><td>Size tiered consider sstables to be within the same bucket if their size is within [average_size * <code>bucket_low</code>, average_size * <code>bucket_high</code> ] (i.e the default groups sstable whose sizes diverges by at most 50%).</td></tr><tr><td><code>sstable_size_in_mb</code>             </td><td>LeveledCompactionStrategy       </td><td>5MB          </td><td>The target size (in MB) for sstables in the leveled strategy. Note that while sstable sizes should stay less or equal to <code>sstable_size_in_mb</code>, it is possible to exceptionally have a larger sstable as during compaction, data for a given partition key are never split into 2 sstables</td></tr><tr><td><code>timestamp_resolution</code>           </td><td>DateTieredCompactionStrategy    </td><td>MICROSECONDS </td><td>The timestamp resolution used when inserting data, could be MILLISECONDS, MICROSECONDS etc (should be understandable by Java TimeUnit) - don&#8217;t change this unless you do mutations with USING TIMESTAMP <non_microsecond_timestamps> (or equivalent directly in the client)</td></tr><tr><td><code>base_time_seconds</code>              </td><td>DateTieredCompactionStrategy    </td><td>60           </td><td>The base size of the time windows. </td></tr><tr><td><code>max_sstable_age_days</code>           </td><td>DateTieredCompactionStrategy    </td><td>365          </td><td>SSTables only containing data that is older than this will never be compacted. </td></tr><tr><td><code>timestamp_resolution</code>           </td><td>TimeWindowCompactionStrategy    </td><td>MICROSECONDS </td><td>The timestamp resolution used when inserting data, could be MILLISECONDS, MICROSECONDS etc (should be understandable by Java TimeUnit) - don&#8217;t change this unless you do mutations with USING TIMESTAMP <non_microsecond_timestamps> (or equivalent directly in the client)</td></tr><tr><td><code>compaction_window_unit</code>         </td><td>TimeWindowCompactionStrategy    </td><td>DAYS         </td><td>The Java TimeUnit used for the window size, set in conjunction with <code>compaction_window_size</code>. Must be one of DAYS, HOURS, MINUTES </td></tr><tr><td><code>compaction_window_size</code>         </td><td>TimeWindowCompactionStrategy    </td><td>1            </td><td>The number of <code>compaction_window_unit</code> units that make up a time window. </td></tr></table><h4 id="compressionOptions">Compression options</h4><p>For the <code>compression</code> property, the following sub-options are available:</p><table><tr><th>option                 </th><th>default        </th><th>description </th></tr><tr><td><code>class</code>                  </td><td>LZ4Compressor    </td><td>The compression algorithm to use. Default compressor are: LZ4Compressor, SnappyCompressor and DeflateCompressor. Use <code>'enabled' : false</code> to disable compression. Custom compressor can be provided by specifying the full class name as a <a href="#constants">string constant</a>.</td></tr><tr><td><code>enabled</code>                </td><td>true             </td><td>By default compression is enabled. To disable it, set <code>enabled</code> to <code>false</code></td></tr><tr><td><code>chunk_length_in_kb</code>     </td><td>64KB             </td><td>On disk SSTables are compressed by block (to allow random reads). This defines the size (in KB) of said block. Bigger values may improve the compression rate, but increases the minimum size of data to be read from disk for a read </td></tr><tr><td><code>crc_check_chance</code>       </td><td>1.0              </td><td>When compression is enabled, each compressed block includes a checksum of that block for the purpose of detecting disk bitrot and avoiding the propagation of corruption to other replica. This option defines the probability with which those checksums are checked during read. By default they are always checked. Set to 0 to disable checksum checking and to 0.5 for instance to check them every other read</td></tr></table><h4 id="cachingOptions">Caching options</h4><p>For the <code>caching</code> property, the following sub-options are available:</p><table><tr><th>option              </th><th>default        </th><th>description </th></tr><tr><td><code>keys</code>                 </td><td>ALL   </td><td>Whether to cache keys (&#171;key cache&#187;) for this table. Valid values are: <code>ALL</code> and <code>NONE</code>.</td></tr><tr><td><code>rows_per_partition</code>   </td><td>NONE   </td><td>The amount of rows to cache per partition (&#171;row cache&#187;). If an integer <code>n</code> is specified, the first <code>n</code> queried rows of a partition will be cached. Other possible options are <code>ALL</code>, to cache all rows of a queried partition, or <code>NONE</code> to disable row caching.</td></tr></table><h4 id="Otherconsiderations">Other considerations:</h4><ul><li>When <a href="#insertStmt">inserting</a> / <a href="#updateStmt">updating</a> a given row, not all columns needs to be defined (except for those part of the key), and missing columns occupy no space on disk. Furthermore, adding new columns (see &lt;a href=#alterStmt><tt>ALTER TABLE</tt></a>) is a constant time operation. There is thus no need to try to anticipate future usage (or to cry when you haven&#8217;t) when creating a table.</li></ul><h3 id="alterTableStmt">ALTER TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;alter-table-stmt> ::= ALTER (TABLE | COLUMNFAMILY) &lt;tablename> &lt;instruction>

&lt;instruction> ::= ALTER &lt;identifier> TYPE &lt;type>
                | ADD   &lt;identifier> &lt;type>
                | DROP  &lt;identifier>
                | WITH  &lt;option> ( AND &lt;option> )*
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>ALTER TABLE addamsFamily
ALTER lastKnownLocation TYPE uuid;

ALTER TABLE addamsFamily
ADD gravesite varchar;

ALTER TABLE addamsFamily
WITH comment = 'A most excellent and useful column family'
 AND read_repair_chance = 0.2;
</pre></pre><p><br/>The <code>ALTER</code> statement is used to manipulate table definitions. It allows for adding new columns, dropping existing ones, changing the type of existing columns, or updating the table options. As with table creation, <code>ALTER COLUMNFAMILY</code> is allowed as an alias for <code>ALTER TABLE</code>.</p><p>The <code>&lt;tablename></code> is the table name optionally preceded by the keyspace name.  The <code>&lt;instruction></code> defines the alteration to perform:</p><ul><li><code>ALTER</code>: Update the type of a given defined column. Note that the type of the <a href="#createTablepartitionClustering">clustering columns</a> cannot be modified as it induces the on-disk ordering of rows. Columns on which a <a href="#createIndexStmt">secondary index</a> is defined have the same restriction. Other columns are free from those restrictions (no validation of existing data is performed), but it is usually a bad idea to change the type to a non-compatible one, unless no data have been inserted for that column yet, as this could confuse CQL drivers/tools.</li><li><code>ADD</code>: Adds a new column to the table. The <code>&lt;identifier></code> for the new column must not conflict with an existing column. Moreover, columns cannot be added to tables defined with the <code>COMPACT STORAGE</code> option.</li><li><code>DROP</code>: Removes a column from the table. Dropped columns will immediately become unavailable in the queries and will not be included in compacted sstables in the future. If a column is readded, queries won&#8217;t return values written before the column was last dropped. It is assumed that timestamps represent actual time, so if this is not your case, you should NOT readd previously dropped columns. Columns can&#8217;t be dropped from tables defined with the <code>COMPACT STORAGE</code> option.</li><li><code>WITH</code>: Allows to update the options of the table. The <a href="#createTableOptions">supported <code>&lt;option></code></a> (and syntax) are the same as for the <code>CREATE TABLE</code> statement except that <code>COMPACT STORAGE</code> is not supported. Note that setting any <code>compaction</code> sub-options has the effect of erasing all previous <code>compaction</code> options, so you  need to re-specify all the sub-options if you want to keep them. The same note applies to the set of <code>compression</code> sub-options.</li></ul><h3 id="dropTableStmt">DROP TABLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-table-stmt> ::= DROP TABLE ( IF EXISTS )? &lt;tablename>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP TABLE worldSeriesAttendees;
</pre></pre><p>The <code>DROP TABLE</code> statement results in the immediate, irreversible removal of a table, including all data contained in it. As for table creation, <code>DROP COLUMNFAMILY</code> is allowed as an alias for <code>DROP TABLE</code>.</p><p>If the table does not exist, the statement will return an error, unless <code>IF EXISTS</code> is used in which case the operation is a no-op.</p><h3 id="truncateStmt">TRUNCATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;truncate-stmt> ::= TRUNCATE ( TABLE | COLUMNFAMILY )? &lt;tablename>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>TRUNCATE superImportantData;
</pre></pre><p>The <code>TRUNCATE</code> statement permanently removes all data from a table.</p><h3 id="createIndexStmt">CREATE INDEX</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-index-stmt> ::= CREATE ( CUSTOM )? INDEX ( IF NOT EXISTS )? ( &lt;indexname> )?
                            ON &lt;tablename> '(' &lt;index-identifier> ')'
                            ( USING &lt;string> ( WITH OPTIONS = &lt;map-literal> )? )?

&lt;index-identifier> ::= &lt;identifier>
                     | keys( &lt;identifier> )
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE INDEX userIndex ON NerdMovies (user);
CREATE INDEX ON Mutants (abilityId);
CREATE INDEX ON users (keys(favs));
CREATE CUSTOM INDEX ON users (email) USING 'path.to.the.IndexClass';
CREATE CUSTOM INDEX ON users (email) USING 'path.to.the.IndexClass' WITH OPTIONS = {'storage': '/mnt/ssd/indexes/'};
</pre></pre><p>The <code>CREATE INDEX</code> statement is used to create a new (automatic) secondary index for a given (existing) column in a given table. A name for the index itself can be specified before the <code>ON</code> keyword, if desired. If data already exists for the column, it will be indexed asynchronously. After the index is created, new data for the column is indexed automatically at insertion time.</p><p>Attempting to create an already existing index will return an error unless the <code>IF NOT EXISTS</code> option is used. If it is used, the statement will be a no-op if the index already exists.</p><h4 id="keysIndex">Indexes on Map Keys</h4><p>When creating an index on a <a href="#map">map column</a>, you may index either the keys or the values.  If the column identifier is placed within the <code>keys()</code> function, the index will be on the map keys, allowing you to use <code>CONTAINS KEY</code> in <code>WHERE</code> clauses.  Otherwise, the index will be on the map values.</p><h3 id="dropIndexStmt">DROP INDEX</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-index-stmt> ::= DROP INDEX ( IF EXISTS )? ( &lt;keyspace> '.' )? &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP INDEX userIndex;

DROP INDEX userkeyspace.address_index;
</pre></pre><p><br/>The <code>DROP INDEX</code> statement is used to drop an existing secondary index. The argument of the statement is the index name, which may optionally specify the keyspace of the index.</p><p>If the index does not exists, the statement will return an error, unless <code>IF EXISTS</code> is used in which case the operation is a no-op.</p><h3 id="createMVStmt">CREATE MATERIALIZED VIEW</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-table-stmt> ::= CREATE MATERIALIZED VIEW ( IF NOT EXISTS )? &lt;viewname> AS
                          SELECT ( '(' &lt;identifier> ( ',' &lt;identifier> ) * ')' | '*' )
                          FROM &lt;tablename>
                          ( WHERE &lt;where-clause> )?
                          PRIMARY KEY '(' &lt;partition-key> ( ',' &lt;identifier> )* ')'
                          ( WITH &lt;option> ( AND &lt;option>)* )?
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE MATERIALIZED VIEW monkeySpecies_by_population AS
    SELECT *
    FROM monkeySpecies
    WHERE population IS NOT NULL AND species IS NOT NULL
    PRIMARY KEY (population, species)
    WITH comment='Allow query by population instead of species';
</pre></pre><p><br/>The <code>CREATE MATERIALIZED VIEW</code> statement creates a new materialized view. Each such view is a set of <em>rows</em> which corresponds to rows which are present in the underlying, or base, table specified in the <code>SELECT</code> statement. A materialized view cannot be directly updated, but updates to the base table will cause corresponding updates in the view.</p><p>Attempting to create an already existing materialized view will return an error unless the <code>IF NOT EXISTS</code> option is used. If it is used, the statement will be a no-op if the materialized view already exists.</p><h4 id="createMVWhere"><code>WHERE</code> Clause</h4><p>The <code>&lt;where-clause></code> is similar to the <a href="#selectWhere">where clause of a <code>SELECT</code> statement</a>, with a few differences.  First, the where clause must contain an expression that disallows <code>NULL</code> values in columns in the view&#8217;s primary key.  If no other restriction is desired, this can be accomplished with an <code>IS NOT NULL</code> expression.  Second, only columns which are in the base table&#8217;s primary key may be restricted with expressions other than <code>IS NOT NULL</code>.  (Note that this second restriction may be lifted in the future.)</p><h3 id="alterMVStmt">ALTER MATERIALIZED VIEW</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;alter-materialized-view-stmt> ::= ALTER MATERIALIZED VIEW &lt;viewname>
                                                 WITH &lt;option> ( AND &lt;option> )*
</pre></pre><p>p.<br/>The <code>ALTER MATERIALIZED VIEW</code> statement allows options to be update; these options are the same as <a href="#createTableOptions"><code>CREATE TABLE</code>'s options</a>.</p><h3 id="dropMVStmt">DROP MATERIALIZED VIEW</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-materialized-stmt> ::= DROP MATERIALIZED VIEW ( IF EXISTS )? &lt;tablename>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>DROP MATERIALIZED VIEW monkeySpecies_by_population;
</pre></pre><p>The <code>DROP MATERIALIZED VIEW</code> statement is used to drop an existing materialized view.</p><p>If the materialized view does not exists, the statement will return an error, unless <code>IF EXISTS</code> is used in which case the operation is a no-op.</p><h3 id="createTypeStmt">CREATE TYPE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-type-stmt> ::= CREATE TYPE ( IF NOT EXISTS )? &lt;typename>
                         '(' &lt;field-definition> ( ',' &lt;field-definition> )* ')'

&lt;typename> ::= ( &lt;keyspace-name> '.' )? &lt;identifier>

&lt;field-definition> ::= &lt;identifier> &lt;type>

</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE TYPE address (
    street_name text,
    street_number int,
    city text,
    state text,
    zip int
)

CREATE TYPE work_and_home_addresses (
    home_address address,
    work_address address
)
</pre></pre><p><br/>The <code>CREATE TYPE</code> statement creates a new user-defined type.  Each type is a set of named, typed fields.  Field types may be any valid type, including collections and other existing user-defined types.</p><p>Attempting to create an already existing type will result in an error unless the <code>IF NOT EXISTS</code> option is used.  If it is used, the statement will be a no-op if the type already exists.</p><h4 id="createTypeName"><code>&lt;typename></code></h4><p>Valid type names are identifiers.  The names of existing CQL types and <a href="#appendixB">reserved type names</a> may not be used.</p><p>If the type name is provided alone, the type is created with the current keyspace (see <a href="#useStmt"><tt>USE</tt></a>). If it is prefixed by an existing keyspace name, the type is created within the specified keyspace instead of the current keyspace.</p><h3 id="alterTypeStmt">ALTER TYPE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;alter-type-stmt> ::= ALTER TYPE &lt;typename> &lt;instruction>

&lt;instruction> ::= ALTER &lt;field-name> TYPE &lt;type>
                | ADD &lt;field-name> &lt;type>
                | RENAME &lt;field-name> TO &lt;field-name> ( AND &lt;field-name> TO &lt;field-name> )*
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>ALTER TYPE address ALTER zip TYPE varint

ALTER TYPE address ADD country text

ALTER TYPE address RENAME zip TO zipcode AND street_name TO street
</pre></pre><p><br/>The <code>ALTER TYPE</code> statement is used to manipulate type definitions. It allows for adding new fields, renaming existing fields, or changing the type of existing fields.</p><p>When altering the type of a column, the new type must be compatible with the previous type.</p><h3 id="dropTypeStmt">DROP TYPE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-type-stmt> ::= DROP TYPE ( IF EXISTS )? &lt;typename>
</pre></pre><p><br/>The <code>DROP TYPE</code> statement results in the immediate, irreversible removal of a type.  Attempting to drop a type that is still in use by another type or a table will result in an error.</p><p>If the type does not exist, an error will be returned unless <code>IF EXISTS</code> is used, in which case the operation is a no-op.</p><h3 id="createTriggerStmt">CREATE TRIGGER</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-trigger-stmt> ::= CREATE TRIGGER ( IF NOT EXISTS )? ( &lt;triggername> )?
                            ON &lt;tablename> 
                            USING &lt;string>

</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE TRIGGER myTrigger ON myTable USING 'org.apache.cassandra.triggers.InvertedIndex';
</pre></pre><p>The actual logic that makes up the trigger can be written in any Java (JVM) language and exists outside the database. You place the trigger code in a <code>lib/triggers</code> subdirectory of the Cassandra installation directory, it loads during cluster startup, and exists on every node that participates in a cluster. The trigger defined on a table fires before a requested DML statement occurs, which ensures the atomicity of the transaction.</p><h3 id="dropTriggerStmt">DROP TRIGGER</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-trigger-stmt> ::= DROP TRIGGER ( IF EXISTS )? ( &lt;triggername> )?
                            ON &lt;tablename>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>DROP TRIGGER myTrigger ON myTable;
</pre></pre><p><code>DROP TRIGGER</code> statement removes the registration of a trigger created using <code>CREATE TRIGGER</code>.</p><h3 id="createFunctionStmt">CREATE FUNCTION</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-function-stmt> ::= CREATE ( OR REPLACE )? 
                            FUNCTION ( IF NOT EXISTS )?
                            ( &lt;keyspace> '.' )? &lt;function-name>
                            '(' &lt;arg-name> &lt;arg-type> ( ',' &lt;arg-name> &lt;arg-type> )* ')'
                            ( CALLED | RETURNS NULL ) ON NULL INPUT
                            RETURNS &lt;type>
                            LANGUAGE &lt;language>
                            AS &lt;body>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE OR REPLACE FUNCTION somefunction
    ( somearg int, anotherarg text, complexarg frozen&lt;someUDT>, listarg list&lt;bigint> )
    RETURNS NULL ON NULL INPUT
    RETURNS text
    LANGUAGE java
    AS $$
       // some Java code
    $$;
CREATE FUNCTION akeyspace.fname IF NOT EXISTS
    ( someArg int )
    CALLED ON NULL INPUT
    RETURNS text
    LANGUAGE java
    AS $$
       // some Java code
    $$;
</pre></pre><p><code>CREATE FUNCTION</code> creates or replaces a user-defined function.</p><h4 id="functionSignature">Function Signature</h4><p>Signatures are used to distinguish individual functions. The signature consists of:</p><ol><li>The fully qualified function name &#8211; i.e <em>keyspace</em> plus <em>function-name</em></li><li>The concatenated list of all argument types</li></ol><p>Note that keyspace names, function names and argument types are subject to the default naming conventions and case-sensitivity rules.</p><p><code>CREATE FUNCTION</code> with the optional <code>OR REPLACE</code> keywords either creates a function or replaces an existing one with the same signature. A <code>CREATE FUNCTION</code> without <code>OR REPLACE</code> fails if a function with the same signature already exists.</p><p>Behavior on invocation with <code>null</code> values must be defined for each function. There are two options:</p><ol><li><code>RETURNS NULL ON NULL INPUT</code> declares that the function will always return <code>null</code> if any of the input arguments is <code>null</code>.</li><li><code>CALLED ON NULL INPUT</code> declares that the function will always be executed.</li></ol><p>If the optional <code>IF NOT EXISTS</code> keywords are used, the function will only be created if another function with the same signature does not exist.</p><p><code>OR REPLACE</code> and <code>IF NOT EXIST</code> cannot be used together.</p><p>Functions belong to a keyspace. If no keyspace is specified in <code>&lt;function-name></code>, the current keyspace is used (i.e. the keyspace specified using the <a href="#useStmt"><code>USE</code></a> statement). It is not possible to create a user-defined function in one of the system keyspaces.</p><p>See the section on <a href="#udfs">user-defined functions</a> for more information.</p><h3 id="dropFunctionStmt">DROP FUNCTION</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-function-stmt> ::= DROP FUNCTION ( IF EXISTS )?
                         ( &lt;keyspace> '.' )? &lt;function-name>
                         ( '(' &lt;arg-type> ( ',' &lt;arg-type> )* ')' )?

</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>DROP FUNCTION myfunction;
DROP FUNCTION mykeyspace.afunction;
DROP FUNCTION afunction ( int );
DROP FUNCTION afunction ( text );
</pre></pre><p><code>DROP FUNCTION</code> statement removes a function created using <code>CREATE FUNCTION</code>.<br/>You must specify the argument types (<a href="#functionSignature">signature</a> ) of the function to drop if there are multiple functions with the same name but a different signature (overloaded functions).</p><p><code>DROP FUNCTION</code> with the optional <code>IF EXISTS</code> keywords drops a function if it exists.</p><h3 id="createAggregateStmt">CREATE AGGREGATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-aggregate-stmt> ::= CREATE ( OR REPLACE )? 
                            AGGREGATE ( IF NOT EXISTS )?
                            ( &lt;keyspace> '.' )? &lt;aggregate-name>
                            '(' &lt;arg-type> ( ',' &lt;arg-type> )* ')'
                            SFUNC &lt;state-functionname>
                            STYPE &lt;state-type>
                            ( FINALFUNC &lt;final-functionname> )?
                            ( INITCOND &lt;init-cond> )?
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>CREATE AGGREGATE myaggregate ( val text )
  SFUNC myaggregate_state
  STYPE text
  FINALFUNC myaggregate_final
  INITCOND 'foo';
</pre></pre><p>See the section on <a href="#udas">user-defined aggregates</a> for a complete example.</p><p><code>CREATE AGGREGATE</code> creates or replaces a user-defined aggregate.</p><p><code>CREATE AGGREGATE</code> with the optional <code>OR REPLACE</code> keywords either creates an aggregate or replaces an existing one with the same signature. A <code>CREATE AGGREGATE</code> without <code>OR REPLACE</code> fails if an aggregate with the same signature already exists.</p><p><code>CREATE AGGREGATE</code> with the optional <code>IF NOT EXISTS</code> keywords either creates an aggregate if it does not already exist.</p><p><code>OR REPLACE</code> and <code>IF NOT EXIST</code> cannot be used together.</p><p>Aggregates belong to a keyspace. If no keyspace is specified in <code>&lt;aggregate-name></code>, the current keyspace is used (i.e. the keyspace specified using the <a href="#useStmt"><code>USE</code></a> statement). It is not possible to create a user-defined aggregate in one of the system keyspaces.</p><p>Signatures for user-defined aggregates follow the <a href="#functionSignature">same rules</a> as for user-defined functions.</p><p><code>STYPE</code> defines the type of the state value and must be specified.</p><p>The optional <code>INITCOND</code> defines the initial state value for the aggregate. It defaults to <code>null</code>. A non-@null@ <code>INITCOND</code> must be specified for state functions that are declared with <code>RETURNS NULL ON NULL INPUT</code>.</p><p><code>SFUNC</code> references an existing function to be used as the state modifying function. The type of first argument of the state function must match <code>STYPE</code>. The remaining argument types of the state function must match the argument types of the aggregate function. State is not updated for state functions declared with <code>RETURNS NULL ON NULL INPUT</code> and called with <code>null</code>.</p><p>The optional <code>FINALFUNC</code> is called just before the aggregate result is returned. It must take only one argument with type <code>STYPE</code>. The return type of the <code>FINALFUNC</code> may be a different type. A final function declared with <code>RETURNS NULL ON NULL INPUT</code> means that the aggregate&#8217;s return value will be <code>null</code>, if the last state is <code>null</code>.</p><p>If no <code>FINALFUNC</code> is defined, the overall return type of the aggregate function is <code>STYPE</code>.  If a <code>FINALFUNC</code> is defined, it is the return type of that function.</p><p>See the section on <a href="#udas">user-defined aggregates</a> for more information.</p><h3 id="dropAggregateStmt">DROP AGGREGATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-aggregate-stmt> ::= DROP AGGREGATE ( IF EXISTS )?
                         ( &lt;keyspace> '.' )? &lt;aggregate-name>
                         ( '(' &lt;arg-type> ( ',' &lt;arg-type> )* ')' )?
</pre></pre><p></p><p><i>Sample:</i></p><pre class="sample"><pre>DROP AGGREGATE myAggregate;
DROP AGGREGATE myKeyspace.anAggregate;
DROP AGGREGATE someAggregate ( int );
DROP AGGREGATE someAggregate ( text );
</pre></pre><p>The <code>DROP AGGREGATE</code> statement removes an aggregate created using <code>CREATE AGGREGATE</code>.  You must specify the argument types of the aggregate to drop if there are multiple aggregates with the same name but a different signature (overloaded aggregates).</p><p><code>DROP AGGREGATE</code> with the optional <code>IF EXISTS</code> keywords drops an aggregate if it exists, and does nothing if a function with the signature does not exist.</p><p>Signatures for user-defined aggregates follow the <a href="#functionSignature">same rules</a> as for user-defined functions.</p><h2 id="dataManipulation">Data Manipulation</h2><h3 id="insertStmt">INSERT</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;insertStatement> ::= INSERT INTO &lt;tablename>
                      ( ( &lt;name-list> VALUES &lt;value-list> )
                      | ( JSON &lt;string> ))
                      ( IF NOT EXISTS )?
                      ( USING &lt;option> ( AND &lt;option> )* )?

&lt;names-list> ::= '(' &lt;identifier> ( ',' &lt;identifier> )* ')'

&lt;value-list> ::= '(' &lt;term-or-literal> ( ',' &lt;term-or-literal> )* ')'

&lt;term-or-literal> ::= &lt;term>
                    | &lt;collection-literal>

&lt;option> ::= TIMESTAMP &lt;integer>
           | TTL &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>INSERT INTO NerdMovies (movie, director, main_actor, year)
                VALUES ('Serenity', 'Joss Whedon', 'Nathan Fillion', 2005)
USING TTL 86400;

INSERT INTO NerdMovies JSON '{"movie": "Serenity", "director": "Joss Whedon", "year": 2005}'
</pre></pre><p><br/>The <code>INSERT</code> statement writes one or more columns for a given row in a table. Note that since a row is identified by its <code>PRIMARY KEY</code>, at least the columns composing it must be specified.  The list of columns to insert to must be supplied when using the <code>VALUES</code> syntax.  When using the <code>JSON</code> syntax, they are optional.  See the section on <a href="#insertJson"><code>INSERT JSON</code></a> for more details.</p><p>Note that unlike in SQL, <code>INSERT</code> does not check the prior existence of the row by default: the row is created if none existed before, and updated otherwise. Furthermore, there is no mean to know which of creation or update happened.</p><p>It is however possible to use the <code>IF NOT EXISTS</code> condition to only insert if the row does not exist prior to the insertion. But please note that using <code>IF NOT EXISTS</code> will incur a non negligible performance cost (internally, Paxos will be used) so this should be used sparingly.</p><p>All updates for an <code>INSERT</code> are applied atomically and in isolation.</p><p>Please refer to the <a href="#updateOptions"><code>UPDATE</code></a> section for information on the <code>&lt;option></code> available and to the <a href="#collections">collections</a> section for use of <code>&lt;collection-literal></code>. Also note that <code>INSERT</code> does not support counters, while <code>UPDATE</code> does.</p><h3 id="updateStmt">UPDATE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;update-stmt> ::= UPDATE &lt;tablename>
                  ( USING &lt;option> ( AND &lt;option> )* )?
                  SET &lt;assignment> ( ',' &lt;assignment> )*
                  WHERE &lt;where-clause>
                  ( IF &lt;condition> ( AND condition )* )?

&lt;assignment> ::= &lt;identifier> '=' &lt;term>
               | &lt;identifier> '=' &lt;identifier> ('+' | '-') (&lt;int-term> | &lt;set-literal> | &lt;list-literal>)
               | &lt;identifier> '=' &lt;identifier> '+' &lt;map-literal>
               | &lt;identifier> '[' &lt;term> ']' '=' &lt;term>

&lt;condition> ::= &lt;identifier> &lt;op> &lt;term>
              | &lt;identifier> IN (&lt;variable> | '(' ( &lt;term> ( ',' &lt;term> )* )? ')')
              | &lt;identifier> '[' &lt;term> ']' &lt;op> &lt;term>
              | &lt;identifier> '[' &lt;term> ']' IN &lt;term>

&lt;op> ::= '&lt;' | '&lt;=' | '=' | '!=' | '>=' | '>'

&lt;where-clause> ::= &lt;relation> ( AND &lt;relation> )*

&lt;relation> ::= &lt;identifier> '=' &lt;term>
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' '=' &lt;term-tuple>
             | &lt;identifier> IN '(' ( &lt;term> ( ',' &lt;term>)* )? ')'
             | &lt;identifier> IN &lt;variable>
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' IN '(' ( &lt;term-tuple> ( ',' &lt;term-tuple>)* )? ')'
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' IN &lt;variable>

&lt;option> ::= TIMESTAMP &lt;integer>
           | TTL &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>UPDATE NerdMovies USING TTL 400
SET director = 'Joss Whedon',
    main_actor = 'Nathan Fillion',
    year = 2005
WHERE movie = 'Serenity';

UPDATE UserActions SET total = total + 2 WHERE user = B70DE1D0-9908-4AE3-BE34-5573E5B09F14 AND action = 'click';
</pre></pre><p><br/>The <code>UPDATE</code> statement writes one or more columns for a given row in a table. The <code>&lt;where-clause></code> is used to select the row to update and must include all columns composing the <code>PRIMARY KEY</code>. Other columns values are specified through <code>&lt;assignment></code> after the <code>SET</code> keyword.</p><p>Note that unlike in SQL, <code>UPDATE</code> does not check the prior existence of the row by default (except through the use of <code>&lt;condition></code>, see below): the row is created if none existed before, and updated otherwise. Furthermore, there are no means to know whether a creation or update occurred.</p><p>It is however possible to use the conditions on some columns through <code>IF</code>, in which case the row will not be updated unless the conditions are met. But, please note that using <code>IF</code> conditions will incur a non-negligible performance cost (internally, Paxos will be used) so this should be used sparingly.</p><p>In an <code>UPDATE</code> statement, all updates within the same partition key are applied atomically and in isolation.</p><p>The <code>c = c + 3</code> form of <code>&lt;assignment></code> is used to increment/decrement counters. The identifier after the &#8249;=&#8250; sign <strong>must</strong> be the same than the one before the &#8249;=&#8250; sign (Only increment/decrement is supported on counters, not the assignment of a specific value).</p><p>The <code>id = id + &lt;collection-literal></code> and <code>id[value1] = value2</code> forms of <code>&lt;assignment></code> are for collections. Please refer to the <a href="#collections">relevant section</a> for more details.</p><h4 id="updateOptions"><code>&lt;options></code></h4><p>The <code>UPDATE</code> and <code>INSERT</code> statements support the following options:</p><ul><li><code>TIMESTAMP</code>: sets the timestamp for the operation. If not specified, the coordinator will use the current time (in microseconds) at the start of statement execution as the timestamp. This is usually a suitable default.</li><li><code>TTL</code>: specifies an optional Time To Live (in seconds) for the inserted values. If set, the inserted values are automatically removed from the database after the specified time. Note that the TTL concerns the inserted values, not the columns themselves. This means that any subsequent update of the column will also reset the TTL (to whatever TTL is specified in that update). By default, values never expire. A TTL of 0 or a negative value is equivalent to no TTL.</li></ul><h3 id="deleteStmt">DELETE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;delete-stmt> ::= DELETE ( &lt;selection> ( ',' &lt;selection> )* )?
                  FROM &lt;tablename>
                  ( USING TIMESTAMP &lt;integer>)?
                  WHERE &lt;where-clause>
                  ( IF ( EXISTS | ( &lt;condition> ( AND &lt;condition> )*) ) )?

&lt;selection> ::= &lt;identifier> ( '[' &lt;term> ']' )?

&lt;where-clause> ::= &lt;relation> ( AND &lt;relation> )*

&lt;relation> ::= &lt;identifier> &lt;op> &lt;term>
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' &lt;op> &lt;term-tuple>
             | &lt;identifier> IN '(' ( &lt;term> ( ',' &lt;term>)* )? ')'
             | &lt;identifier> IN &lt;variable>
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' IN '(' ( &lt;term-tuple> ( ',' &lt;term-tuple>)* )? ')'
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' IN &lt;variable>

&lt;op> ::= '=' | '&lt;' | '>' | '&lt;=' | '>='

&lt;condition> ::= &lt;identifier> (&lt;op> | '!=') &lt;term>
              | &lt;identifier> IN (&lt;variable> | '(' ( &lt;term> ( ',' &lt;term> )* )? ')')
              | &lt;identifier> '[' &lt;term> ']' (&lt;op> | '!=') &lt;term>
              | &lt;identifier> '[' &lt;term> ']' IN &lt;term>

</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>DELETE FROM NerdMovies USING TIMESTAMP 1240003134 WHERE movie = 'Serenity';

DELETE phone FROM Users WHERE userid IN (C73DE1D3-AF08-40F3-B124-3FF3E5109F22, B70DE1D0-9908-4AE3-BE34-5573E5B09F14);
</pre></pre><p><br/>The <code>DELETE</code> statement deletes columns and rows. If column names are provided directly after the <code>DELETE</code> keyword, only those columns are deleted from the row indicated by the <code>&lt;where-clause></code> (the <code>id[value]</code> syntax in <code>&lt;selection></code> is for collection, please refer to the <a href="#collections">collection section</a> for more details).  Otherwise, whole rows are removed. The <code>&lt;where-clause></code> specifies which rows are to be deleted.  Multiple rows may be deleted with one statement by using an <code>IN</code> clause.  A range of rows may be deleted using an inequality operator (such as <code>>=</code>).</p><p><code>DELETE</code> supports the <code>TIMESTAMP</code> option with the same semantics as the <a href="#updateStmt"><code>UPDATE</code></a> statement.</p><p>In a <code>DELETE</code> statement, all deletions within the same partition key are applied atomically and in isolation.</p><p>A <code>DELETE</code> operation can be conditional through the use of an <code>IF</code> clause, similar to <code>UPDATE</code> and <code>INSERT</code> statements. However, as with <code>INSERT</code> and <code>UPDATE</code> statements, this will incur a non-negligible performance cost (internally, Paxos will be used) and so should be used sparingly.</p><h3 id="batchStmt">BATCH</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;batch-stmt> ::= BEGIN ( UNLOGGED | COUNTER ) BATCH
                 ( USING &lt;option> ( AND &lt;option> )* )?
                    &lt;modification-stmt> ( ';' &lt;modification-stmt> )*
                 APPLY BATCH

&lt;modification-stmt> ::= &lt;insert-stmt>
                      | &lt;update-stmt>
                      | &lt;delete-stmt>

&lt;option> ::= TIMESTAMP &lt;integer>
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>BEGIN BATCH
  INSERT INTO users (userid, password, name) VALUES ('user2', 'ch@ngem3b', 'second user');
  UPDATE users SET password = 'ps22dhds' WHERE userid = 'user3';
  INSERT INTO users (userid, password) VALUES ('user4', 'ch@ngem3c');
  DELETE name FROM users WHERE userid = 'user1';
APPLY BATCH;
</pre></pre><p>The <code>BATCH</code> statement group multiple modification statements (insertions/updates and deletions) into a single statement. It serves several purposes:</p><ol><li>It saves network round-trips between the client and the server (and sometimes between the server coordinator and the replicas) when batching multiple updates.</li><li>All updates in a <code>BATCH</code> belonging to a given partition key are performed in isolation.</li><li>By default, all operations in the batch are performed as <code>LOGGED</code>, to ensure all mutations eventually complete (or none will).  See the notes on <a href="#unloggedBatch"><code>UNLOGGED</code></a> for more details.</li></ol><p>Note that:</p><ul><li><code>BATCH</code> statements may only contain <code>UPDATE</code>, <code>INSERT</code> and <code>DELETE</code> statements.</li><li>Batches are <em>not</em> a full analogue for SQL transactions.</li><li>If a timestamp is not specified for each operation, then all operations will be applied with the same timestamp. Due to Cassandra&#8217;s conflict resolution procedure in the case of <a href="http://wiki.apache.org/cassandra/FAQ#clocktie">timestamp ties</a>, operations may be applied in an order that is different from the order they are listed in the <code>BATCH</code> statement. To force a particular operation ordering, you must specify per-operation timestamps.</li></ul><h4 id="unloggedBatch"><code>UNLOGGED</code></h4><p>By default, Cassandra uses a batch log to ensure all operations in a batch eventually complete or none will (note however that operations are only isolated within a single partition).</p><p>There is a performance penalty for batch atomicity when a batch spans multiple partitions. If you do not want to incur this penalty, you can tell Cassandra to skip the batchlog with the <code>UNLOGGED</code> option. If the <code>UNLOGGED</code> option is used, a failed batch might leave the patch only partly applied.</p><h4 id="counterBatch"><code>COUNTER</code></h4><p>Use the <code>COUNTER</code> option for batched counter updates.  Unlike other updates in Cassandra, counter updates are not idempotent.</p><h4 id="batchOptions"><code>&lt;option></code></h4><p><code>BATCH</code> supports both the <code>TIMESTAMP</code> option, with similar semantic to the one described in the <a href="#updateOptions"><code>UPDATE</code></a> statement (the timestamp applies to all the statement inside the batch). However, if used, <code>TIMESTAMP</code> <strong>must not</strong> be used in the statements within the batch.</p><h2 id="queries">Queries</h2><h3 id="selectStmt">SELECT</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;select-stmt> ::= SELECT ( JSON )? &lt;select-clause>
                  FROM &lt;tablename>
                  ( WHERE &lt;where-clause> )?
                  ( ORDER BY &lt;order-by> )?
                  ( LIMIT &lt;integer> )?
                  ( ALLOW FILTERING )?

&lt;select-clause> ::= DISTINCT? &lt;selection-list>
                  | COUNT '(' ( '*' | '1' ) ')' (AS &lt;identifier>)?

&lt;selection-list> ::= &lt;selector> (AS &lt;identifier>)? ( ',' &lt;selector> (AS &lt;identifier>)? )*
                   | '*'

&lt;selector> ::= &lt;identifier>
             | WRITETIME '(' &lt;identifier> ')'
             | TTL '(' &lt;identifier> ')'
             | &lt;function> '(' (&lt;selector> (',' &lt;selector>)*)? ')'

&lt;where-clause> ::= &lt;relation> ( AND &lt;relation> )*

&lt;relation> ::= &lt;identifier> &lt;op> &lt;term>
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' &lt;op> &lt;term-tuple>
             | &lt;identifier> IN '(' ( &lt;term> ( ',' &lt;term>)* )? ')'
             | '(' &lt;identifier> (',' &lt;identifier>)* ')' IN '(' ( &lt;term-tuple> ( ',' &lt;term-tuple>)* )? ')'
             | TOKEN '(' &lt;identifier> ( ',' &lt;identifer>)* ')' &lt;op> &lt;term>

&lt;op> ::= '=' | '&lt;' | '>' | '&lt;=' | '>=' | CONTAINS | CONTAINS KEY
&lt;order-by> ::= &lt;ordering> ( ',' &lt;odering> )*
&lt;ordering> ::= &lt;identifer> ( ASC | DESC )?
&lt;term-tuple> ::= '(' &lt;term> (',' &lt;term>)* ')'
</pre></pre><p><br/><i>Sample:</i></p><pre class="sample"><pre>SELECT name, occupation FROM users WHERE userid IN (199, 200, 207);

SELECT JSON name, occupation FROM users WHERE userid = 199;

SELECT name AS user_name, occupation AS user_occupation FROM users;

SELECT time, value
FROM events
WHERE event_type = 'myEvent'
  AND time > '2011-02-03'
  AND time &lt;= '2012-01-01'

SELECT COUNT(*) FROM users;

SELECT COUNT(*) AS user_count FROM users;

</pre></pre><p><br/>The <code>SELECT</code> statements reads one or more columns for one or more rows in a table. It returns a result-set of rows, where each row contains the collection of columns corresponding to the query.  If the <code>JSON</code> keyword is used, the results for each row will contain only a single column named &#171;json&#187;.  See the section on <a href="#selectJson"><code>SELECT JSON</code></a> for more details.</p><h4 id="selectSelection"><code>&lt;select-clause></code></h4><p>The <code>&lt;select-clause></code> determines which columns needs to be queried and returned in the result-set. It consists of either the comma-separated list of <selector> or the wildcard character (<code>*</code>) to select all the columns defined for the table.</p><p>A <code>&lt;selector></code> is either a column name to retrieve or a <code>&lt;function></code> of one or more @<term>@s. The function allowed are the same as for <code>&lt;term></code> and are described in the <a href="#functions">function section</a>. In addition to these generic functions, the <code>WRITETIME</code> (resp. <code>TTL</code>) function allows to select the timestamp of when the column was inserted (resp. the time to live (in seconds) for the column (or null if the column has no expiration set)).</p><p>Any <code>&lt;selector></code> can be aliased using <code>AS</code> keyword (see examples). Please note that <code>&lt;where-clause></code> and <code>&lt;order-by></code> clause should refer to the columns by their original names and not by their aliases.</p><p>The <code>COUNT</code> keyword can be used with parenthesis enclosing <code>*</code>. If so, the query will return a single result: the number of rows matching the query. Note that <code>COUNT(1)</code> is supported as an alias.</p><h4 id="selectWhere"><code>&lt;where-clause></code></h4><p>The <code>&lt;where-clause></code> specifies which rows must be queried. It is composed of relations on the columns that are part of the <code>PRIMARY KEY</code> and/or have a <a href="#createIndexStmt">secondary index</a> defined on them.</p><p>Not all relations are allowed in a query. For instance, non-equal relations (where <code>IN</code> is considered as an equal relation) on a partition key are not supported (but see the use of the <code>TOKEN</code> method below to do non-equal queries on the partition key). Moreover, for a given partition key, the clustering columns induce an ordering of rows and relations on them is restricted to the relations that allow to select a <strong>contiguous</strong> (for the ordering) set of rows. For instance, given</p><pre class="sample"><pre>CREATE TABLE posts (
    userid text,
    blog_title text,
    posted_at timestamp,
    entry_title text,
    content text,
    category int,
    PRIMARY KEY (userid, blog_title, posted_at)
)
</pre></pre><p>The following query is allowed:</p><pre class="sample"><pre>SELECT entry_title, content FROM posts WHERE userid='john doe' AND blog_title='John''s Blog' AND posted_at >= '2012-01-01' AND posted_at &lt; '2012-01-31'
</pre></pre><p>But the following one is not, as it does not select a contiguous set of rows (and we suppose no secondary indexes are set):</p><pre class="sample"><pre>// Needs a blog_title to be set to select ranges of posted_at
SELECT entry_title, content FROM posts WHERE userid='john doe' AND posted_at >= '2012-01-01' AND posted_at &lt; '2012-01-31'
</pre></pre><p>When specifying relations, the <code>TOKEN</code> function can be used on the <code>PARTITION KEY</code> column to query. In that case, rows will be selected based on the token of their <code>PARTITION_KEY</code> rather than on the value. Note that the token of a key depends on the partitioner in use, and that in particular the RandomPartitioner won&#8217;t yield a meaningful order. Also note that ordering partitioners always order token values by bytes (so even if the partition key is of type int, <code>token(-1) > token(0)</code> in particular). Example:</p><pre class="sample"><pre>SELECT * FROM posts WHERE token(userid) > token('tom') AND token(userid) &lt; token('bob')
</pre></pre><p>Moreover, the <code>IN</code> relation is only allowed on the last column of the partition key and on the last column of the full primary key.</p><p>It is also possible to &#171;group&#187; <code>CLUSTERING COLUMNS</code> together in a relation using the tuple notation. For instance:</p><pre class="sample"><pre>SELECT * FROM posts WHERE userid='john doe' AND (blog_title, posted_at) > ('John''s Blog', '2012-01-01')
</pre></pre><p>will request all rows that sorts after the one having &#171;John's Blog&#187; as <code>blog_tile</code> and &#8249;2012-01-01&#8250; for <code>posted_at</code> in the clustering order. In particular, rows having a <code>post_at &lt;= '2012-01-01'</code> will be returned as long as their <code>blog_title > 'John''s Blog'</code>, which wouldn&#8217;t be the case for:</p><pre class="sample"><pre>SELECT * FROM posts WHERE userid='john doe' AND blog_title > 'John''s Blog' AND posted_at > '2012-01-01'
</pre></pre><p>The tuple notation may also be used for <code>IN</code> clauses on <code>CLUSTERING COLUMNS</code>:</p><pre class="sample"><pre>SELECT * FROM posts WHERE userid='john doe' AND (blog_title, posted_at) IN (('John''s Blog', '2012-01-01), ('Extreme Chess', '2014-06-01'))
</pre></pre><p>The <code>CONTAINS</code> operator may only be used on collection columns (lists, sets, and maps).  In the case of maps, <code>CONTAINS</code> applies to the map values. The <code>CONTAINS KEY</code> operator may only be used on map columns and applies to the map keys.</p><h4 id="selectOrderBy"><code>&lt;order-by></code></h4><p>The <code>ORDER BY</code> option allows to select the order of the returned results. It takes as argument a list of column names along with the order for the column (<code>ASC</code> for ascendant and <code>DESC</code> for descendant, omitting the order being equivalent to <code>ASC</code>). Currently the possible orderings are limited (which depends on the table <a href="#createTableOptions"><code>CLUSTERING ORDER</code></a> ):</p><ul><li>if the table has been defined without any specific <code>CLUSTERING ORDER</code>, then then allowed orderings are the order induced by the clustering columns and the reverse of that one.</li><li>otherwise, the orderings allowed are the order of the <code>CLUSTERING ORDER</code> option and the reversed one.</li></ul><h4 id="selectLimit"><code>LIMIT</code></h4><p>The <code>LIMIT</code> option to a <code>SELECT</code> statement limits the number of rows returned by a query.</p><h4 id="selectAllowFiltering"><code>ALLOW FILTERING</code></h4><p>By default, CQL only allows select queries that don&#8217;t involve &#171;filtering&#187; server side, i.e. queries where we know that all (live) record read will be returned (maybe partly) in the result set. The reasoning is that those &#171;non filtering&#187; queries have predictable performance in the sense that they will execute in a time that is proportional to the amount of data <strong>returned</strong> by the query (which can be controlled through <code>LIMIT</code>).</p><p>The <code>ALLOW FILTERING</code> option allows to explicitly allow (some) queries that require filtering. Please note that a query using <code>ALLOW FILTERING</code> may thus have unpredictable performance (for the definition above), i.e. even a query that selects a handful of records <strong>may</strong> exhibit performance that depends on the total amount of data stored in the cluster.</p><p>For instance, considering the following table holding user profiles with their year of birth (with a secondary index on it) and country of residence:</p><pre class="sample"><pre>CREATE TABLE users (
    username text PRIMARY KEY,
    firstname text,
    lastname text,
    birth_year int,
    country text
)

CREATE INDEX ON users(birth_year);
</pre></pre><p></p><p>Then the following queries are valid:</p><pre class="sample"><pre>SELECT * FROM users;
SELECT firstname, lastname FROM users WHERE birth_year = 1981;
</pre></pre><p>because in both case, Cassandra guarantees that these queries performance will be proportional to the amount of data returned. In particular, if no users are born in 1981, then the second query performance will not depend of the number of user profile stored in the database (not directly at least: due to secondary index implementation consideration, this query may still depend on the number of node in the cluster, which indirectly depends on the amount of data stored.  Nevertheless, the number of nodes will always be multiple number of magnitude lower than the number of user profile stored). Of course, both query may return very large result set in practice, but the amount of data returned can always be controlled by adding a <code>LIMIT</code>.</p><p>However, the following query will be rejected:</p><pre class="sample"><pre>SELECT firstname, lastname FROM users WHERE birth_year = 1981 AND country = 'FR';
</pre></pre><p>because Cassandra cannot guarantee that it won&#8217;t have to scan large amount of data even if the result to those query is small. Typically, it will scan all the index entries for users born in 1981 even if only a handful are actually from France. However, if you &#171;know what you are doing&#187;, you can force the execution of this query by using <code>ALLOW FILTERING</code> and so the following query is valid:</p><pre class="sample"><pre>SELECT firstname, lastname FROM users WHERE birth_year = 1981 AND country = 'FR' ALLOW FILTERING;
</pre></pre><h2 id="databaseRoles">Database Roles</h2><h3 id="createRoleStmt">CREATE ROLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;create-role-stmt> ::= CREATE ROLE ( IF NOT EXISTS )? &lt;identifier> ( WITH &lt;option> ( AND &lt;option> )* )?

&lt;option> ::= PASSWORD = &lt;string>
           | LOGIN = &lt;boolean>
           | SUPERUSER = &lt;boolean>
           | OPTIONS = &lt;map_literal>
</pre></pre><p></p><p><i>Sample:</i></p><pre class="sample"><pre>CREATE ROLE new_role;
CREATE ROLE alice WITH PASSWORD = 'password_a' AND LOGIN = true;
CREATE ROLE bob WITH PASSWORD = 'password_b' AND LOGIN = true AND SUPERUSER = true;
CREATE ROLE carlos WITH OPTIONS = { 'custom_option1' : 'option1_value', 'custom_option2' : 99 };
</pre></pre><p>By default roles do not possess <code>LOGIN</code> privileges or <code>SUPERUSER</code> status.</p><p><a href="#permissions">Permissions</a> on database resources are granted to roles; types of resources include keyspaces, tables, functions and roles themselves. Roles may be granted to other roles to create hierarchical permissions structures; in these hierarchies, permissions and <code>SUPERUSER</code> status are inherited, but the <code>LOGIN</code> privilege is not. </p><p>If a role has the <code>LOGIN</code> privilege, clients may identify as that role when connecting. For the duration of that connection, the client will acquire any roles and privileges granted to that role.</p><p>Only a client with with the <code>CREATE</code> permission on the database roles resource may issue <code>CREATE ROLE</code> requests (see the <a href="#permissions">relevant section</a> below), unless the client is a <code>SUPERUSER</code>. Role management in Cassandra is pluggable and custom implementations may support only a subset of the listed options.</p><p>Role names should be quoted if they contain non-alphanumeric characters. </p><h4 id="createRolePwd">Setting credentials for internal authentication</h4><p>Use the <code>WITH PASSWORD</code> clause to set a password for internal authentication, enclosing the password in single quotation marks.<br/>If internal authentication has not been set up or the role does not have <code>LOGIN</code> privileges, the <code>WITH PASSWORD</code> clause is not necessary.</p><h4 id="createRoleConditional">Creating a role conditionally</h4><p>Attempting to create an existing role results in an invalid query condition unless the <code>IF NOT EXISTS</code> option is used. If the option is used and the role exists, the statement is a no-op.</p><pre class="sample"><pre>CREATE ROLE other_role;
CREATE ROLE IF NOT EXISTS other_role;
</pre></pre><h3 id="alterRoleStmt">ALTER ROLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;alter-role-stmt> ::= ALTER ROLE &lt;identifier> ( WITH &lt;option> ( AND &lt;option> )* )?

&lt;option> ::= PASSWORD = &lt;string>
           | LOGIN = &lt;boolean>
           | SUPERUSER = &lt;boolean>
           | OPTIONS = &lt;map_literal>
</pre></pre><p></p><p><i>Sample:</i></p><pre class="sample"><pre>ALTER ROLE bob WITH PASSWORD = 'PASSWORD_B' AND SUPERUSER = false;
</pre></pre><p>Conditions on executing <code>ALTER ROLE</code> statements:</p><ul><li>A client must have <code>SUPERUSER</code> status to alter the <code>SUPERUSER</code> status of another role</li><li>A client cannot alter the <code>SUPERUSER</code> status of any role it currently holds</li><li>A client can only modify certain properties of the role with which it identified at login (e.g. <code>PASSWORD</code>)</li><li>To modify properties of a role, the client must be granted <code>ALTER</code> <a href="#permissions">permission</a> on that role</li></ul><h3 id="dropRoleStmt">DROP ROLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;drop-role-stmt> ::= DROP ROLE ( IF EXISTS )? &lt;identifier>
</pre></pre><p></p><p><i>Sample:</i></p><pre class="sample"><pre>DROP ROLE alice;
DROP ROLE IF EXISTS bob;
</pre></pre><p><code>DROP ROLE</code> requires the client to have <code>DROP</code> <a href="#permissions">permission</a> on the role in question. In addition, client may not <code>DROP</code> the role with which it identified at login. Finaly, only a client with <code>SUPERUSER</code> status may <code>DROP</code> another <code>SUPERUSER</code> role.<br/>Attempting to drop a role which does not exist results in an invalid query condition unless the <code>IF EXISTS</code> option is used. If the option is used and the role does not exist the statement is a no-op. </p><h3 id="grantRoleStmt">GRANT ROLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;grant-role-stmt> ::= GRANT &lt;identifier> TO &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>GRANT report_writer TO alice;
</pre></pre><p>This statement grants the <code>report_writer</code> role to <code>alice</code>. Any permissions granted to <code>report_writer</code> are also acquired by <code>alice</code>.<br/>Roles are modelled as a directed acyclic graph, so circular grants are not permitted. The following examples result in error conditions:</p><pre class="sample"><pre>GRANT role_a TO role_b;
GRANT role_b TO role_a;
</pre></pre><pre class="sample"><pre>GRANT role_a TO role_b;
GRANT role_b TO role_c;
GRANT role_c TO role_a;
</pre></pre><h3 id="revokeRoleStmt">REVOKE ROLE</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;revoke-role-stmt> ::= REVOKE &lt;identifier> FROM &lt;identifier>
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>REVOKE report_writer FROM alice;
</pre></pre><p>This statement revokes the <code>report_writer</code> role from <code>alice</code>. Any permissions that <code>alice</code> has acquired via the <code>report_writer</code> role are also revoked. </p><h4 id="listRolesStmt">LIST ROLES</h4><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;list-roles-stmt> ::= LIST ROLES ( OF &lt;identifier> )? ( NORECURSIVE )?
</pre></pre><p><i>Sample:</i> </p><pre class="sample"><pre>LIST ROLES;
</pre></pre><p>Return all known roles in the system, this requires <code>DESCRIBE</code> permission on the database roles resource.</p><pre class="sample"><pre>LIST ROLES OF @alice@;
</pre></pre><p>Enumerate all roles granted to <code>alice</code>, including those transitively aquired.</p><pre class="sample"><pre>LIST ROLES OF @bob@ NORECURSIVE
</pre></pre><p>List all roles directly granted to <code>bob</code>.</p><h3 id="createUserStmt">CREATE USER </h3><p>Prior to the introduction of roles in Cassandra 2.2, authentication and authorization were based around the concept of a <code>USER</code>. For backward compatibility, the legacy syntax has been preserved with <code>USER</code> centric statments becoming synonyms for the <code>ROLE</code> based equivalents.</p><p><i>Syntax:</i> </p><pre class="syntax"><pre>&lt;create-user-statement> ::= CREATE USER ( IF NOT EXISTS )? &lt;identifier> ( WITH PASSWORD &lt;string> )? (&lt;option>)?

&lt;option> ::= SUPERUSER
           | NOSUPERUSER
</pre></pre><p></p><p><i>Sample:</i> </p><pre class="sample"><pre>CREATE USER alice WITH PASSWORD 'password_a' SUPERUSER;
CREATE USER bob WITH PASSWORD 'password_b' NOSUPERUSER;
</pre></pre><p><code>CREATE USER</code> is equivalent to <code>CREATE ROLE</code> where the <code>LOGIN</code> option is <code>true</code>. So, the following pairs of statements are equivalent:</p><pre class="sample"><pre>CREATE USER alice WITH PASSWORD 'password_a' SUPERUSER;
CREATE ROLE alice WITH PASSWORD = 'password_a' AND LOGIN = true AND SUPERUSER = true;

CREATE USER IF EXISTS alice WITH PASSWORD 'password_a' SUPERUSER;
CREATE ROLE IF EXISTS alice WITH PASSWORD = 'password_a' AND LOGIN = true AND SUPERUSER = true;

CREATE USER alice WITH PASSWORD 'password_a' NOSUPERUSER;
CREATE ROLE alice WITH PASSWORD = 'password_a' AND LOGIN = true AND SUPERUSER = false;

CREATE USER alice WITH PASSWORD 'password_a' NOSUPERUSER;
CREATE ROLE alice WITH PASSWORD = 'password_a' WITH LOGIN = true;

CREATE USER alice WITH PASSWORD 'password_a';
CREATE ROLE alice WITH PASSWORD = 'password_a' WITH LOGIN = true;
</pre></pre><p></p><h3 id="alterUserStmt">ALTER USER </h3><p><i>Syntax:</i> </p><pre class="syntax"><pre>&lt;alter-user-statement> ::= ALTER USER &lt;identifier> ( WITH PASSWORD &lt;string> )? ( &lt;option> )?

&lt;option> ::= SUPERUSER
           | NOSUPERUSER
</pre></pre><p></p><pre class="sample"><pre>ALTER USER alice WITH PASSWORD 'PASSWORD_A';
ALTER USER bob SUPERUSER;
</pre></pre><h3 id="dropUserStmt">DROP USER </h3><p><i>Syntax:</i> </p><pre class="syntax"><pre>&lt;drop-user-stmt> ::= DROP USER ( IF EXISTS )? &lt;identifier>
</pre></pre><p></p><p><i>Sample:</i> </p><pre class="sample"><pre>DROP USER alice;
DROP USER IF EXISTS bob;
</pre></pre><h3 id="listUsersStmt">LIST USERS</h3><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;list-users-stmt> ::= LIST USERS;
</pre></pre><p><i>Sample:</i></p><pre class="sample"><pre>LIST USERS;
</pre></pre><p>This statement is equivalent to</p><pre class="sample"><pre>LIST ROLES;
</pre></pre><p>but only roles with the <code>LOGIN</code> privilege are included in the output.</p><h2 id="dataControl">Data Control</h2><h3 id="permissions">Permissions </h3><p>Permissions on resources are granted to roles; there are several different types of resources in Cassandra and each type is modelled hierarchically:</p><ul><li>The hierarchy of Data resources, Keyspaces and Tables has the structure <code>ALL KEYSPACES</code> -> <code>KEYSPACE</code> -> <code>TABLE</code></li><li>Function resources have the structure <code>ALL FUNCTIONS</code> -> <code>KEYSPACE</code> -> <code>FUNCTION</code></li><li>Resources representing roles have the structure <code>ALL ROLES</code> -> <code>ROLE</code></li></ul><p>Permissions can be granted at any level of these hierarchies and they flow downwards. So granting a permission on a resource higher up the chain automatically grants that same permission on all resources lower down. For example, granting <code>SELECT</code> on a <code>KEYSPACE</code> automatically grants it on all <code>TABLES</code> in that <code>KEYSPACE</code>. Likewise, granting a permission on <code>ALL FUNCTIONS</code> grants it on every defined function, regardless of which keyspace it is scoped in. It is also possible to grant permissions on all functions scoped to a particular keyspace. </p><p>Modifications to permissions are visible to existing client sessions; that is, connections need not be re-established following permissions changes.</p><p>The full set of available permissions is:</p><ul><li><code>CREATE</code></li><li><code>ALTER</code></li><li><code>DROP</code></li><li><code>SELECT</code></li><li><code>MODIFY</code></li><li><code>AUTHORIZE</code></li><li><code>DESCRIBE</code></li><li><code>EXECUTE</code></li></ul><p>Not all permissions are applicable to every type of resource. For instance, <code>EXECUTE</code> is only relevant in the context of functions; granting <code>EXECUTE</code> on a resource representing a table is nonsensical. Attempting to <code>GRANT</code> a permission on resource to which it cannot be applied results in an error response. The following illustrates which permissions can be granted on which types of resource, and which statements are enabled by that permission.</p><table><tr><th>permission </th><th>resource                   </th><th>operations        </th></tr><tr><td><code>CREATE</code>     </td><td><code>ALL KEYSPACES</code>              </td><td><code>CREATE KEYSPACE</code> <br> <code>CREATE TABLE</code> in any keyspace</td></tr><tr><td><code>CREATE</code>     </td><td><code>KEYSPACE</code>                   </td><td><code>CREATE TABLE</code> in specified keyspace</td></tr><tr><td><code>CREATE</code>     </td><td><code>ALL FUNCTIONS</code>              </td><td><code>CREATE FUNCTION</code> in any keyspace <br> <code>CREATE AGGREGATE</code> in any keyspace</td></tr><tr><td><code>CREATE</code>     </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>CREATE FUNCTION</code> in keyspace <br> <code>CREATE AGGREGATE</code> in keyspace</td></tr><tr><td><code>CREATE</code>     </td><td><code>ALL ROLES</code>                  </td><td><code>CREATE ROLE</code></td></tr><tr><td><code>ALTER</code>      </td><td><code>ALL KEYSPACES</code>              </td><td><code>ALTER KEYSPACE</code> <br> <code>ALTER TABLE</code> in any keyspace</td></tr><tr><td><code>ALTER</code>      </td><td><code>KEYSPACE</code>                   </td><td><code>ALTER KEYSPACE</code> <br> <code>ALTER TABLE</code> in keyspace</td></tr><tr><td><code>ALTER</code>      </td><td><code>TABLE</code>                      </td><td><code>ALTER TABLE</code></td></tr><tr><td><code>ALTER</code>      </td><td><code>ALL FUNCTIONS</code>              </td><td><code>CREATE FUNCTION</code> replacing any existing <br> <code>CREATE AGGREGATE</code> replacing any existing</td></tr><tr><td><code>ALTER</code>      </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>CREATE FUNCTION</code> replacing existing in keyspace <br> <code>CREATE AGGREGATE</code> replacing any existing in keyspace</td></tr><tr><td><code>ALTER</code>      </td><td><code>FUNCTION</code>                   </td><td><code>CREATE FUNCTION</code> replacing existing <br> <code>CREATE AGGREGATE</code> replacing existing</td></tr><tr><td><code>ALTER</code>      </td><td><code>ALL ROLES</code>                  </td><td><code>ALTER ROLE</code> on any role</td></tr><tr><td><code>ALTER</code>      </td><td><code>ROLE</code>                       </td><td><code>ALTER ROLE</code></td></tr><tr><td><code>DROP</code>       </td><td><code>ALL KEYSPACES</code>              </td><td><code>DROP KEYSPACE</code> <br> <code>DROP TABLE</code> in any keyspace</td></tr><tr><td><code>DROP</code>       </td><td><code>KEYSPACE</code>                   </td><td><code>DROP TABLE</code> in specified keyspace</td></tr><tr><td><code>DROP</code>       </td><td><code>TABLE</code>                      </td><td><code>DROP TABLE</code></td></tr><tr><td><code>DROP</code>       </td><td><code>ALL FUNCTIONS</code>              </td><td><code>DROP FUNCTION</code> in any keyspace <br> <code>DROP AGGREGATE</code> in any existing</td></tr><tr><td><code>DROP</code>       </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>DROP FUNCTION</code> in keyspace <br> <code>DROP AGGREGATE</code> in existing</td></tr><tr><td><code>DROP</code>       </td><td><code>FUNCTION</code>                   </td><td><code>DROP FUNCTION</code></td></tr><tr><td><code>DROP</code>       </td><td><code>ALL ROLES</code>                  </td><td><code>DROP ROLE</code> on any role</td></tr><tr><td><code>DROP</code>       </td><td><code>ROLE</code>                       </td><td><code>DROP ROLE</code></td></tr><tr><td><code>SELECT</code>     </td><td><code>ALL KEYSPACES</code>              </td><td><code>SELECT</code> on any table</td></tr><tr><td><code>SELECT</code>     </td><td><code>KEYSPACE</code>                   </td><td><code>SELECT</code> on any table in keyspace</td></tr><tr><td><code>SELECT</code>     </td><td><code>TABLE</code>                      </td><td><code>SELECT</code> on specified table</td></tr><tr><td><code>MODIFY</code>     </td><td><code>ALL KEYSPACES</code>              </td><td><code>INSERT</code> on any table <br> <code>UPDATE</code> on any table <br> <code>DELETE</code> on any table <br> <code>TRUNCATE</code> on any table</td></tr><tr><td><code>MODIFY</code>     </td><td><code>KEYSPACE</code>                  </td><td><code>INSERT</code> on any table in keyspace <br> <code>UPDATE</code> on any table in keyspace <br>  == @DELETE@ on any table in keyspace ==<br> <code>TRUNCATE</code> on any table in keyspace</td></tr><tr><td><code>MODIFY</code>     </td><td><code>TABLE</code>                      </td><td><code>INSERT</code> <br> <code>UPDATE</code> <br> <code>DELETE</code> <br> <code>TRUNCATE</code></td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ALL KEYSPACES</code>              </td><td><code>GRANT PERMISSION</code> on any table <br> <code>REVOKE PERMISSION</code> on any table</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>KEYSPACE</code>                   </td><td><code>GRANT PERMISSION</code> on table in keyspace <br> <code>REVOKE PERMISSION</code> on table in keyspace</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>TABLE</code>                      </td><td><code>GRANT PERMISSION</code> <br> <code>REVOKE PERMISSION</code> </td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ALL FUNCTIONS</code>              </td><td><code>GRANT PERMISSION</code> on any function <br> <code>REVOKE PERMISSION</code> on any function</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>GRANT PERMISSION</code> in keyspace <br> <code>REVOKE PERMISSION</code> in keyspace</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>GRANT PERMISSION</code> in keyspace <br> <code>REVOKE PERMISSION</code> in keyspace</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>FUNCTION</code>                   </td><td><code>GRANT PERMISSION</code> <br> <code>REVOKE PERMISSION</code></td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ALL ROLES</code>                  </td><td><code>GRANT ROLE</code> grant any role <br> <code>REVOKE ROLE</code> revoke any role</td></tr><tr><td><code>AUTHORIZE</code>  </td><td><code>ROLES</code>                      </td><td><code>GRANT ROLE</code> grant role <br> <code>REVOKE ROLE</code> revoke role</td></tr><tr><td><code>DESCRIBE</code>   </td><td><code>ALL ROLES</code>                  </td><td><code>LIST ROLES</code> all roles or only roles granted to another, specified role</td></tr><tr><td><code>EXECUTE</code>    </td><td><code>ALL FUNCTIONS</code>              </td><td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> using any function <br> use of any function in <code>CREATE AGGREGATE</code></td></tr><tr><td><code>EXECUTE</code>    </td><td><code>ALL FUNCTIONS IN KEYSPACE</code>  </td><td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> using any function in keyspace <br> use of any function in keyspace in <code>CREATE AGGREGATE</code></td></tr><tr><td><code>EXECUTE</code>    </td><td><code>FUNCTION</code>                   </td><td><code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code> using function <br> use of function in <code>CREATE AGGREGATE</code></td></tr></table><h3 id="grantPermissionsStmt">GRANT PERMISSION</h3><p><i>Syntax:</i> </p><pre class="syntax"><pre>&lt;grant-permission-stmt> ::= GRANT ( ALL ( PERMISSIONS )? | &lt;permission> ( PERMISSION )? ) ON &lt;resource> TO &lt;identifier>

&lt;permission> ::= CREATE | ALTER | DROP | SELECT | MODIFY | AUTHORIZE | DESRIBE | EXECUTE

&lt;resource> ::= ALL KEYSPACES
             | KEYSPACE &lt;identifier>
             | ( TABLE )? &lt;tablename>
             | ALL ROLES
             | ROLE &lt;identifier>
             | ALL FUNCTIONS ( IN KEYSPACE &lt;identifier> )?
             | FUNCTION &lt;functionname>
</pre></pre><p></p><p><i>Sample:</i> </p><pre class="sample"><pre>GRANT SELECT ON ALL KEYSPACES TO data_reader;
</pre></pre><p>This gives any user with the role <code>data_reader</code> permission to execute <code>SELECT</code> statements on any table across all keyspaces</p><pre class="sample"><pre>GRANT MODIFY ON KEYSPACE keyspace1 TO data_writer;
</pre></pre><p>This give any user with the role <code>data_writer</code> permission to perform <code>UPDATE</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> and <code>TRUNCATE</code> queries on all tables in the <code>keyspace1</code> keyspace</p><pre class="sample"><pre>GRANT DROP ON keyspace1.table1 TO schema_owner;
</pre></pre><p>This gives any user with the <code>schema_owner</code> role permissions to <code>DROP</code> <code>keyspace1.table1</code>.</p><pre class="sample"><pre>GRANT EXECUTE ON FUNCTION keyspace1.user_function( int ) TO report_writer;
</pre></pre><p>This grants any user with the <code>report_writer</code> role permission to execute <code>SELECT</code>, <code>INSERT</code> and <code>UPDATE</code> queries which use the function <code>keyspace1.user_function( int )</code></p><pre class="sample"><pre>GRANT DESCRIBE ON ALL ROLES TO role_admin;
</pre></pre><p>This grants any user with the <code>role_admin</code> role permission to view any and all roles in the system with a <code>LIST ROLES</code> statement</p><h4 id="grantAll">GRANT ALL </h4><p>When the <code>GRANT ALL</code> form is used, the appropriate set of permissions is determined automatically based on the target resource.</p><h4 id="autoGrantPermissions">Automatic Granting</h4><p>When a resource is created, via a <code>CREATE KEYSPACE</code>, <code>CREATE TABLE</code>, <code>CREATE FUNCTION</code>, <code>CREATE AGGREGATE</code> or <code>CREATE ROLE</code> statement, the creator (the role the database user who issues the statement is identified as), is automatically granted all applicable permissions on the new resource.</p><h3 id="revokePermissionsStmt">REVOKE PERMISSION</h3><p><i>Syntax:</i> </p><pre class="syntax"><pre>&lt;revoke-permission-stmt> ::= REVOKE ( ALL ( PERMISSIONS )? | &lt;permission> ( PERMISSION )? ) ON &lt;resource> FROM &lt;identifier>

&lt;permission> ::= CREATE | ALTER | DROP | SELECT | MODIFY | AUTHORIZE | DESRIBE | EXECUTE

&lt;resource> ::= ALL KEYSPACES
             | KEYSPACE &lt;identifier>
             | ( TABLE )? &lt;tablename>
             | ALL ROLES
             | ROLE &lt;identifier>
             | ALL FUNCTIONS ( IN KEYSPACE &lt;identifier> )?
             | FUNCTION &lt;functionname>
</pre></pre><p></p><p><i>Sample:</i> </p><pre class="sample"><pre>REVOKE SELECT ON ALL KEYSPACES FROM data_reader;
REVOKE MODIFY ON KEYSPACE keyspace1 FROM data_writer;
REVOKE DROP ON keyspace1.table1 FROM schema_owner;
REVOKE EXECUTE ON FUNCTION keyspace1.user_function( int ) FROM report_writer;
REVOKE DESCRIBE ON ALL ROLES FROM role_admin;
</pre></pre><p></p><h4 id="listPermissionsStmt">LIST PERMISSIONS</h4><p><i>Syntax:</i></p><pre class="syntax"><pre>&lt;list-permissions-stmt> ::= LIST ( ALL ( PERMISSIONS )? | &lt;permission> ) 
                                 ( ON &lt;resource> )? 
                                 ( OF &lt;identifier> ( NORECURSIVE )? )?

&lt;resource> ::= ALL KEYSPACES
             | KEYSPACE &lt;identifier>
             | ( TABLE )? &lt;tablename>
             | ALL ROLES
             | ROLE &lt;identifier>
             | ALL FUNCTIONS ( IN KEYSPACE &lt;identifier> )?
             | FUNCTION &lt;functionname>
</pre></pre><p></p><p><i>Sample:</i></p><pre class="sample"><pre>LIST ALL PERMISSIONS OF alice;
</pre></pre><p>Show all permissions granted to <code>alice</code>, including those acquired transitively from any other roles. </p><pre class="sample"><pre>LIST ALL PERMISSIONS ON keyspace1.table1 OF bob;
</pre></pre><p>Show all permissions on <code>keyspace1.table1</code> granted to <code>bob</code>, including those acquired transitively from any other roles. This also includes any permissions higher up the resource hierarchy which can be applied to <code>keyspace1.table1</code>. For example, should <code>bob</code> have <code>ALTER</code> permission on <code>keyspace1</code>, that would be included in the results of this query. Adding the <code>NORECURSIVE</code> switch restricts the results to only those permissions which were directly granted to <code>bob</code> or one of <code>bob</code>'s roles.</p><pre class="sample"><pre>LIST SELECT PERMISSIONS OF carlos;
</pre></pre><p>Show any permissions granted to <code>carlos</code> or any of <code>carlos</code>'s roles, limited to <code>SELECT</code> permissions on any resource.</p><h2 id="types">Data Types</h2><p>CQL supports a rich set of data types for columns defined in a table, including collection types. On top of those native and collection types, users can also provide custom types (through a JAVA class extending <code>AbstractType</code> loadable by Cassandra). The syntax of types is thus:</p><pre class="syntax"><pre>&lt;type> ::= &lt;native-type>
         | &lt;collection-type>
         | &lt;tuple-type>
         | &lt;string>       // Used for custom types. The fully-qualified name of a JAVA class

&lt;native-type> ::= ascii
                | bigint
                | blob
                | boolean
                | counter
                | date
                | decimal
                | double
                | float
                | inet
                | int
                | smallint
                | text
                | time
                | timestamp
                | timeuuid
                | tinyint
                | uuid
                | varchar
                | varint

&lt;collection-type> ::= list '&lt;' &lt;native-type> '>'
                    | set  '&lt;' &lt;native-type> '>'
                    | map  '&lt;' &lt;native-type> ',' &lt;native-type> '>'
&lt;tuple-type> ::= tuple '&lt;' &lt;type> (',' &lt;type>)* '>'
</pre></pre><p>Note that the native types are keywords and as such are case-insensitive. They are however not reserved ones.</p><p>The following table gives additional informations on the native data types, and on which kind of <a href="#constants">constants</a> each type supports:</p><table><tr><th>type    </th><th>constants supported</th><th>description</th></tr><tr><td><code>ascii</code>    </td><td>  strings            </td><td>ASCII character string</td></tr><tr><td><code>bigint</code>   </td><td>  integers           </td><td>64-bit signed long</td></tr><tr><td><code>blob</code>     </td><td>  blobs              </td><td>Arbitrary bytes (no validation)</td></tr><tr><td><code>boolean</code>  </td><td>  booleans           </td><td>true or false</td></tr><tr><td><code>counter</code>  </td><td>  integers           </td><td>Counter column (64-bit signed value). See <a href="#counters">Counters</a> for details</td></tr><tr><td><code>date</code>     </td><td>  integers, strings  </td><td>A date (with no corresponding time value).  See <a href="#usingdates">Working with dates</a> below for more information.</td></tr><tr><td><code>decimal</code>  </td><td>  integers, floats   </td><td>Variable-precision decimal</td></tr><tr><td><code>double</code>   </td><td>  integers           </td><td>64-bit IEEE-754 floating point</td></tr><tr><td><code>float</code>    </td><td>  integers, floats   </td><td>32-bit IEEE-754 floating point</td></tr><tr><td><code>inet</code>     </td><td>  strings            </td><td>An IP address. It can be either 4 bytes long (IPv4) or 16 bytes long (IPv6). There is no <code>inet</code> constant, IP address should be inputed as strings</td></tr><tr><td><code>int</code>      </td><td>  integers           </td><td>32-bit signed int</td></tr><tr><td><code>smallint</code> </td><td>  integers           </td><td>16-bit signed int</td></tr><tr><td><code>text</code>     </td><td>  strings            </td><td>UTF8 encoded string</td></tr><tr><td><code>time</code>     </td><td>  integers, strings  </td><td>A time with nanosecond precision.  See <a href="#usingtime">Working with time</a> below for more information.</td></tr><tr><td><code>timestamp</code></td><td>  integers, strings  </td><td>A timestamp. Strings constant are allow to input timestamps as dates, see <a href="#usingtimestamps">Working with timestamps</a> below for more information.</td></tr><tr><td><code>timeuuid</code> </td><td>  uuids              </td><td>Type 1 UUID. This is generally used as a &#171;conflict-free&#187; timestamp. Also see the <a href="#timeuuidFun">functions on Timeuuid</a></td></tr><tr><td><code>tinyint</code>  </td><td>  integers           </td><td>8-bit signed int</td></tr><tr><td><code>uuid</code>     </td><td>  uuids              </td><td>Type 1 or type 4 UUID</td></tr><tr><td><code>varchar</code>  </td><td>  strings            </td><td>UTF8 encoded string</td></tr><tr><td><code>varint</code>   </td><td>  integers           </td><td>Arbitrary-precision integer</td></tr></table><p>For more information on how to use the collection types, see the <a href="#collections">Working with collections</a> section below.</p><h3 id="usingtimestamps">Working with timestamps</h3><p>Values of the <code>timestamp</code> type are encoded as 64-bit signed integers representing a number of milliseconds since the standard base time known as &#171;the epoch&#187;: January 1 1970 at 00:00:00 GMT.</p><p>Timestamp can be input in CQL as simple long integers, giving the number of milliseconds since the epoch, as defined above.</p><p>They can also be input as string literals in any of the following ISO 8601 formats, each representing the time and date Mar 2, 2011, at 04:05:00 AM, GMT.:</p><ul><li><code>2011-02-03 04:05+0000</code></li><li><code>2011-02-03 04:05:00+0000</code></li><li><code>2011-02-03 04:05:00.000+0000</code></li><li><code>2011-02-03T04:05+0000</code></li><li><code>2011-02-03T04:05:00+0000</code></li><li><code>2011-02-03T04:05:00.000+0000</code></li></ul><p>The <code>+0000</code> above is an RFC 822 4-digit time zone specification; <code>+0000</code> refers to GMT. US Pacific Standard Time is <code>-0800</code>. The time zone may be omitted if desired&#8212; the date will be interpreted as being in the time zone under which the coordinating Cassandra node is configured.</p><ul><li><code>2011-02-03 04:05</code></li><li><code>2011-02-03 04:05:00</code></li><li><code>2011-02-03 04:05:00.000</code></li><li><code>2011-02-03T04:05</code></li><li><code>2011-02-03T04:05:00</code></li><li><code>2011-02-03T04:05:00.000</code></li></ul><p>There are clear difficulties inherent in relying on the time zone configuration being as expected, though, so it is recommended that the time zone always be specified for timestamps when feasible.</p><p>The time of day may also be omitted, if the date is the only piece that matters:</p><ul><li><code>2011-02-03</code></li><li><code>2011-02-03+0000</code></li></ul><p>In that case, the time of day will default to 00:00:00, in the specified or default time zone.</p><h3 id="usingdates">Working with dates</h3><p>Values of the <code>date</code> type are encoded as 32-bit unsigned integers representing a number of days with &#171;the epoch&#187; at the center of the range (2^31). Epoch is January 1st, 1970</p><p>A date can be input in CQL as an unsigned integer as defined above.</p><p>They can also be input as string literals in the following format:</p><ul><li><code>2014-01-01</code></li></ul><h3 id="usingtime">Working with time</h3><p>Values of the <code>time</code> type are encoded as 64-bit signed integers representing the number of nanoseconds since midnight.</p><p>A time can be input in CQL as simple long integers, giving the number of nanoseconds since midnight.</p><p>They can also be input as string literals in any of the following formats:</p><ul><li><code>08:12:54</code></li><li><code>08:12:54.123</code></li><li><code>08:12:54.123456</code></li><li><code>08:12:54.123456789</code></li></ul><h3 id="counters">Counters</h3><p>The <code>counter</code> type is used to define <em>counter columns</em>. A counter column is a column whose value is a 64-bit signed integer and on which 2 operations are supported: incrementation and decrementation (see <a href="#updateStmt"><code>UPDATE</code></a> for syntax).  Note the value of a counter cannot be set. A counter doesn&#8217;t exist until first incremented/decremented, and the first incrementation/decrementation is made as if the previous value was 0. Deletion of counter columns is supported but have some limitations (see the <a href="http://wiki.apache.org/cassandra/Counters">Cassandra Wiki</a> for more information).</p><p>The use of the counter type is limited in the following way:</p><ul><li>It cannot be used for column that is part of the <code>PRIMARY KEY</code> of a table.</li><li>A table that contains a counter can only contain counters. In other words, either all the columns of a table outside the <code>PRIMARY KEY</code> have the counter type, or none of them have it.</li></ul><h3 id="collections">Working with collections</h3><h4 id="Noteworthycharacteristics">Noteworthy characteristics</h4><p>Collections are meant for storing/denormalizing relatively small amount of data. They work well for things like &#171;the phone numbers of a given user&#187;, &#171;labels applied to an email&#187;, etc. But when items are expected to grow unbounded (&#171;all the messages sent by a given user&#187;, &#171;events registered by a sensor&#187;, ...), then collections are not appropriate anymore and a specific table (with clustering columns) should be used. Concretely, collections have the following limitations:</p><ul><li>Collections are always read in their entirety (and reading one is not paged internally).</li><li>Collections cannot have more than 65535 elements. More precisely, while it may be possible to insert more than 65535 elements, it is not possible to read more than the 65535 first elements (see <a href="https://issues.apache.org/jira/browse/CASSANDRA-5428">CASSANDRA-5428</a> for details).</li><li>While insertion operations on sets and maps never incur a read-before-write internally, some operations on lists do (see the section on lists below for details). It is thus advised to prefer sets over lists when possible.</li></ul><p>Please note that while some of those limitations may or may not be loosen in the future, the general rule that collections are for denormalizing small amount of data is meant to stay.</p><h4 id="map">Maps</h4><p>A <code>map</code> is a <a href="#types">typed</a> set of key-value pairs, where keys are unique. Furthermore, note that the map are internally sorted by their keys and will thus always be returned in that order. To create a column of type <code>map</code>, use the <code>map</code> keyword suffixed with comma-separated key and value types, enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE users (
    id text PRIMARY KEY,
    given text,
    surname text,
    favs map&lt;text, text>   // A map of text keys, and text values
)
</pre></pre><p>Writing <code>map</code> data is accomplished with a JSON-inspired syntax. To write a record using <code>INSERT</code>, specify the entire map as a JSON-style associative array. <em>Note: This form will always replace the entire map.</em></p><pre class="sample"><pre>// Inserting (or Updating)
INSERT INTO users (id, given, surname, favs)
           VALUES ('jsmith', 'John', 'Smith', { 'fruit' : 'apple', 'band' : 'Beatles' })
</pre></pre><p>Adding or updating key-values of a (potentially) existing map can be accomplished either by subscripting the map column in an <code>UPDATE</code> statement or by adding a new map literal:</p><pre class="sample"><pre>// Updating (or inserting)
UPDATE users SET favs['author'] = 'Ed Poe' WHERE id = 'jsmith'
UPDATE users SET favs = favs +  { 'movie' : 'Cassablanca' } WHERE id = 'jsmith'
</pre></pre><p>Note that TTLs are allowed for both <code>INSERT</code> and <code>UPDATE</code>, but in both case the TTL set only apply to the newly inserted/updated <em>values</em>. In other words,</p><pre class="sample"><pre>// Updating (or inserting)
UPDATE users USING TTL 10 SET favs['color'] = 'green' WHERE id = 'jsmith'
</pre></pre><p>will only apply the TTL to the <code>{ 'color' : 'green' }</code> record, the rest of the map remaining unaffected.</p><p>Deleting a map record is done with:</p><pre class="sample"><pre>DELETE favs['author'] FROM users WHERE id = 'jsmith'
</pre></pre><h4 id="set">Sets</h4><p>A <code>set</code> is a <a href="#types">typed</a> collection of unique values. Sets are ordered by their values. To create a column of type <code>set</code>, use the <code>set</code> keyword suffixed with the value type enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE images (
    name text PRIMARY KEY,
    owner text,
    date timestamp,
    tags set&lt;text>
);
</pre></pre><p>Writing a <code>set</code> is accomplished by comma separating the set values, and enclosing them in curly braces.  <em>Note: An <code>INSERT</code> will always replace the entire set.</em></p><pre class="sample"><pre>INSERT INTO images (name, owner, date, tags)
            VALUES ('cat.jpg', 'jsmith', 'now', { 'kitten', 'cat', 'pet' });
</pre></pre><p>Adding and removing values of a set can be accomplished with an <code>UPDATE</code> by adding/removing new set values to an existing <code>set</code> column.</p><pre class="sample"><pre>UPDATE images SET tags = tags + { 'cute', 'cuddly' } WHERE name = 'cat.jpg';
UPDATE images SET tags = tags - { 'lame' } WHERE name = 'cat.jpg';
</pre></pre><p>As with <a href="#map">maps</a>, TTLs if used only apply to the newly inserted/updated <em>values</em>.</p><h4 id="list">Lists</h4><p>A <code>list</code> is a <a href="#types">typed</a> collection of non-unique values where elements are ordered by there position in the list.  To create a column of type <code>list</code>, use the <code>list</code> keyword suffixed with the value type enclosed in angle brackets.  For example:</p><pre class="sample"><pre>CREATE TABLE plays (
    id text PRIMARY KEY,
    game text,
    players int,
    scores list&lt;int>
)
</pre></pre><p>Do note that as explained below, lists have some limitations and performance considerations to take into account, and it is advised to prefer <a href="#set">sets</a> over lists when this is possible.</p><p>Writing <code>list</code> data is accomplished with a JSON-style syntax.  To write a record using <code>INSERT</code>, specify the entire list as a JSON array.  <em>Note: An <code>INSERT</code> will always replace the entire list.</em></p><pre class="sample"><pre>INSERT INTO plays (id, game, players, scores)
           VALUES ('123-afde', 'quake', 3, [17, 4, 2]);
</pre></pre><p>Adding (appending or prepending) values to a list can be accomplished by adding a new JSON-style array to an existing <code>list</code> column.</p><pre class="sample"><pre>UPDATE plays SET players = 5, scores = scores + [ 14, 21 ] WHERE id = '123-afde';
UPDATE plays SET players = 5, scores = [ 12 ] + scores WHERE id = '123-afde';
</pre></pre><p>It should be noted that append and prepend are not idempotent operations. This means that if during an append or a prepend the operation timeout, it is not always safe to retry the operation (as this could result in the record appended or prepended twice).</p><p>Lists also provides the following operation: setting an element by its position in the list, removing an element by its position in the list and remove all the occurrence of a given value in the list. <em>However, and contrarily to all the other collection operations, these three operations induce an internal read before the update, and will thus typically have slower performance characteristics</em>. Those operations have the following syntax:</p><pre class="sample"><pre>UPDATE plays SET scores[1] = 7 WHERE id = '123-afde';                // sets the 2nd element of scores to 7 (raises an error is scores has less than 2 elements)
DELETE scores[1] FROM plays WHERE id = '123-afde';                   // deletes the 2nd element of scores (raises an error is scores has less than 2 elements)
UPDATE plays SET scores = scores - [ 12, 21 ] WHERE id = '123-afde'; // removes all occurrences of 12 and 21 from scores
</pre></pre><p>As with <a href="#map">maps</a>, TTLs if used only apply to the newly inserted/updated <em>values</em>.</p><h2 id="functions">Functions</h2><p>CQL3 distinguishes between built-in functions (so called &#8249;native functions&#8250;) and <a href="#udfs">user-defined functions</a>.  CQL3 includes several native functions, described below:</p><h3 id="tokenFun">Token</h3><p>The <code>token</code> function allows to compute the token for a given partition key. The exact signature of the token function depends on the table concerned and of the partitioner used by the cluster.</p><p>The type of the arguments of the <code>token</code> depend on the type of the partition key columns. The return type depend on the partitioner in use:</p><ul><li>For Murmur3Partitioner, the return type is <code>bigint</code>.</li><li>For RandomPartitioner, the return type is <code>varint</code>.</li><li>For ByteOrderedPartitioner, the return type is <code>blob</code>.</li></ul><p>For instance, in a cluster using the default Murmur3Partitioner, if a table is defined by</p><pre class="sample"><pre>CREATE TABLE users (
    userid text PRIMARY KEY,
    username text,
    ...
)
</pre></pre><p>then the <code>token</code> function will take a single argument of type <code>text</code> (in that case, the partition key is <code>userid</code> (there is no clustering columns so the partition key is the same than the primary key)), and the return type will be <code>bigint</code>.</p><h3 id="uuidFun">Uuid</h3><p>The <code>uuid</code> function takes no parameters and generates a random type 4 uuid suitable for use in INSERT or SET statements.</p><h3 id="timeuuidFun">Timeuuid functions</h3><h4 id="now"><code>now</code></h4><p>The <code>now</code> function takes no arguments and generates, on the coordinator node, a new unique timeuuid (at the time where the statement using it is executed). Note that this method is useful for insertion but is largely non-sensical in <code>WHERE</code> clauses. For instance, a query of the form</p><pre class="sample"><pre>SELECT * FROM myTable WHERE t = now()
</pre></pre><p>will never return any result by design, since the value returned by <code>now()</code> is guaranteed to be unique.</p><h4 id="minTimeuuidandmaxTimeuuid"><code>minTimeuuid</code> and <code>maxTimeuuid</code></h4><p>The <code>minTimeuuid</code> (resp. <code>maxTimeuuid</code>) function takes a <code>timestamp</code> value <code>t</code> (which can be <a href="#usingtimestamps">either a timestamp or a date string</a> ) and return a <em>fake</em> <code>timeuuid</code> corresponding to the <em>smallest</em> (resp. <em>biggest</em>) possible <code>timeuuid</code> having for timestamp <code>t</code>. So for instance:</p><pre class="sample"><pre>SELECT * FROM myTable WHERE t > maxTimeuuid('2013-01-01 00:05+0000') AND t &lt; minTimeuuid('2013-02-02 10:00+0000')
</pre></pre><p>will select all rows where the <code>timeuuid</code> column <code>t</code> is strictly older than &#8249;2013-01-01 00:05+0000&#8250; but strictly younger than &#8249;2013-02-02 10:00+0000&#8250;.  Please note that <code>t >= maxTimeuuid('2013-01-01 00:05+0000')</code> would still <em>not</em> select a <code>timeuuid</code> generated exactly at &#8249;2013-01-01 00:05+0000&#8250; and is essentially equivalent to <code>t > maxTimeuuid('2013-01-01 00:05+0000')</code>.</p><p><em>Warning</em>: We called the values generated by <code>minTimeuuid</code> and <code>maxTimeuuid</code> <em>fake</em> UUID because they do no respect the Time-Based UUID generation process specified by the <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a>. In particular, the value returned by these 2 methods will not be unique. This means you should only use those methods for querying (as in the example above). Inserting the result of those methods is almost certainly <em>a bad idea</em>.</p><h3 id="timeFun">Time conversion functions</h3><p>A number of functions are provided to &#171;convert&#187; a <code>timeuuid</code>, a <code>timestamp</code> or a <code>date</code> into another <code>native</code> type.</p><table><tr><th>function name    </th><th>input type   </th><th>description</th></tr><tr><td><code>toDate</code>            </td><td><code>timeuuid</code>      </td><td>Converts the <code>timeuuid</code> argument into a <code>date</code> type</td></tr><tr><td><code>toDate</code>            </td><td><code>timestamp</code>     </td><td>Converts the <code>timestamp</code> argument into a <code>date</code> type</td></tr><tr><td><code>toTimestamp</code>       </td><td><code>timeuuid</code>      </td><td>Converts the <code>timeuuid</code> argument into a <code>timestamp</code> type</td></tr><tr><td><code>toTimestamp</code>       </td><td><code>date</code>          </td><td>Converts the <code>date</code> argument into a <code>timestamp</code> type</td></tr><tr><td><code>toUnixTimestamp</code>   </td><td><code>timeuuid</code>      </td><td>Converts the <code>timeuuid</code> argument into a <code>bigInt</code> raw value</td></tr><tr><td><code>toUnixTimestamp</code>   </td><td><code>timestamp</code>     </td><td>Converts the <code>timestamp</code> argument into a <code>bigInt</code> raw value</td></tr><tr><td><code>toUnixTimestamp</code>   </td><td><code>date</code>          </td><td>Converts the <code>date</code> argument into a <code>bigInt</code> raw value</td></tr><tr><td><code>dateOf</code>            </td><td><code>timeuuid</code>      </td><td>Similar to <code>toTimestamp(timeuuid)</code> (DEPRECATED)</td></tr><tr><td><code>unixTimestampOf</code>   </td><td><code>timeuuid</code>      </td><td>Similar to <code>toUnixTimestamp(timeuuid)</code> (DEPRECATED)</td></tr></table><h3 id="blobFun">Blob conversion functions</h3><p>A number of functions are provided to &#171;convert&#187; the native types into binary data (<code>blob</code>). For every <code>&lt;native-type></code> <code>type</code> supported by CQL3 (a notable exceptions is <code>blob</code>, for obvious reasons), the function <code>typeAsBlob</code> takes a argument of type <code>type</code> and return it as a <code>blob</code>.  Conversely, the function <code>blobAsType</code> takes a 64-bit <code>blob</code> argument and convert it to a <code>bigint</code> value.  And so for instance, <code>bigintAsBlob(3)</code> is <code>0x0000000000000003</code> and <code>blobAsBigint(0x0000000000000003)</code> is <code>3</code>.</p><h2 id="aggregates">Aggregates</h2><p>Aggregate functions work on a set of rows. They receive values for each row and returns one value for the whole set.<br/>If <code>normal</code> columns, <code>scalar functions</code>, <code>UDT</code> fields, <code>writetime</code> or <code>ttl</code> are selected together with aggregate functions, the values returned for them will be the ones of the first row matching the query.</p><p>CQL3 distinguishes between built-in aggregates (so called &#8249;native aggregates&#8250;) and <a href="#udas">user-defined aggregates</a>. CQL3 includes several native aggregates, described below:</p><h3 id="countFct">Count</h3><p>The <code>count</code> function can be used to count the rows returned by a query. Example:</p><pre class="sample"><pre>SELECT COUNT(*) FROM plays;
SELECT COUNT(1) FROM plays;
</pre></pre><p>It also can be used to count the non null value of a given column. Example:</p><pre class="sample"><pre>SELECT COUNT(scores) FROM plays;
</pre></pre><h3 id="maxMinFcts">Max and Min</h3><p>The <code>max</code> and <code>min</code> functions can be used to compute the maximum and the minimum value returned by a query for a given column.</p><pre class="sample"><pre>SELECT MIN(players), MAX(players) FROM plays WHERE game = 'quake';
</pre></pre><h3 id="sumFct">Sum</h3><p>The <code>sum</code> function can be used to sum up all the values returned by a query for a given column.</p><pre class="sample"><pre>SELECT SUM(players) FROM plays;
</pre></pre><h3 id="avgFct">Avg</h3><p>The <code>avg</code> function can be used to compute the average of all the values returned by a query for a given column.</p><pre class="sample"><pre>SELECT AVG(players) FROM plays;
</pre></pre><h2 id="udfs">User-Defined Functions</h2><p>User-defined functions allow execution of user-provided code in Cassandra. By default, Cassandra supports defining functions in <em>Java</em> and <em>JavaScript</em>. Support for other JSR 223 compliant scripting languages (such as Python, Ruby, and Scala) can be added by adding a JAR to the classpath.</p><p>UDFs are part of the Cassandra schema.  As such, they are automatically propagated to all nodes in the cluster.</p><p>UDFs can be <em>overloaded</em> - i.e. multiple UDFs with different argument types but the same function name. Example:</p><pre class="sample"><pre>CREATE FUNCTION sample ( arg int ) ...;
CREATE FUNCTION sample ( arg text ) ...;
</pre></pre><p>User-defined functions are susceptible to all of the normal problems with the chosen programming language.  Accordingly, implementations should be safe against null pointer exceptions, illegal arguments, or any other potential source of exceptions.  An exception during function execution will result in the entire statement failing.</p><p>It is valid to use <em>complex</em> types like collections, tuple types and user-defined types as argument and return types. Tuple types and user-defined types are handled by the conversion functions of the DataStax Java Driver. Please see the documentation of the Java Driver for details on handling tuple types and user-defined types.</p><p>Arguments for functions can be literals or terms. Prepared statement placeholders can be used, too.</p><p>Note that you can use the double-quoted string syntax to enclose the UDF source code. For example:</p><pre class="sample"><pre>CREATE FUNCTION some_function ( arg int )
  RETURNS NULL ON NULL INPUT
  RETURNS int
  LANGUAGE java
  AS $$ return arg; $$;

SELECT some_function(column) FROM atable ...;
UPDATE atable SET col = some_function(?) ...;
</pre></pre><p></p><pre class="sample"><pre>CREATE TYPE custom_type (txt text, i int);
CREATE FUNCTION fct_using_udt ( udtarg frozen&lt;custom_type> )
  RETURNS NULL ON NULL INPUT
  RETURNS text
  LANGUAGE java
  AS $$ return udtarg.getString("txt"); $$;
</pre></pre><p>User-defined functions can be used in <a href="#selectStmt"><code>SELECT</code></a>, <a href="#insertStmt"><code>INSERT</code></a> and <a href="#updateStmt"><code>UPDATE</code></a> statements.</p><p>See <a href="#createFunctionStmt"><code>CREATE FUNCTION</code></a> and <a href="#dropFunctionStmt"><code>DROP FUNCTION</code></a>.</p><h2 id="udas">User-Defined Aggregates</h2><p>User-defined aggregates allow creation of custom aggregate functions using <a href="#udfs">UDFs</a>. Common examples of aggregate functions are <em>count</em>, <em>min</em>, and <em>max</em>.</p><p>Each aggregate requires an <em>initial state</em> (<code>INITCOND</code>, which defaults to <code>null</code>) of type <code>STYPE</code>. The first argument of the state function must have type <code>STYPE</code>. The remaining arguments of the state function must match the types of the user-defined aggregate arguments. The state function is called once for each row, and the value returned by the state function becomes the new state. After all rows are processed, the optional <code>FINALFUNC</code> is executed with last state value as its argument.</p><p><code>STYPE</code> is mandatory in order to be able to distinguish possibly overloaded versions of the state and/or final function (since the overload can appear after creation of the aggregate).</p><p>User-defined aggregates can be used in <a href="#selectStmt"><code>SELECT</code></a> statement.</p><p>A complete working example for user-defined aggregates (assuming that a keyspace has been selected using the <a href="#useStmt"><code>USE</code></a> statement):</p><pre class="sample"><pre>CREATE OR REPLACE FUNCTION averageState ( state tuple&lt;int,bigint>, val int )
  CALLED ON NULL INPUT
  RETURNS tuple&lt;int,bigint>
  LANGUAGE java
  AS '
    if (val != null) {
      state.setInt(0, state.getInt(0)+1);
      state.setLong(1, state.getLong(1)+val.intValue());
    }
    return state;
  ';

CREATE OR REPLACE FUNCTION averageFinal ( state tuple&lt;int,bigint> )
  CALLED ON NULL INPUT
  RETURNS double
  LANGUAGE java
  AS '
    double r = 0;
    if (state.getInt(0) == 0) return null;
    r = state.getLong(1);
    r /= state.getInt(0);
    return Double.valueOf(r);
  ';

CREATE OR REPLACE AGGREGATE average ( int )
  SFUNC averageState
  STYPE tuple&lt;int,bigint>
  FINALFUNC averageFinal
  INITCOND (0, 0);

CREATE TABLE atable (
  pk int PRIMARY KEY,
  val int);
INSERT INTO atable (pk, val) VALUES (1,1);
INSERT INTO atable (pk, val) VALUES (2,2);
INSERT INTO atable (pk, val) VALUES (3,3);
INSERT INTO atable (pk, val) VALUES (4,4);
SELECT average(val) FROM atable;
</pre></pre><p></p><p>See <a href="#createAggregateStmt"><code>CREATE AGGREGATE</code></a> and <a href="#dropAggregateStmt"><code>DROP AGGREGATE</code></a>.</p><h2 id="json">JSON Support</h2><p>Cassandra 2.2 introduces JSON support to <a href="#selectStmt"><code>SELECT</code></a> and <a href="#insertStmt"><code>INSERT</code></a> statements.  This support does not fundamentally alter the CQL API (for example, the schema is still enforced), it simply provides a convenient way to work with JSON documents.</p><h3 id="selectJson">SELECT JSON</h3><p>With <code>SELECT</code> statements, the new <code>JSON</code> keyword can be used to return each row as a single <code>JSON</code> encoded map.  The remainder of the <code>SELECT</code> statment behavior is the same.</p><p>The result map keys are the same as the column names in a normal result set.  For example, a statement like "<code>SELECT JSON a, ttl(b) FROM ...</code>" would result in a map with keys <code>"a"</code> and <code>"ttl(b)"</code>.  However, this is one notable exception: for symmetry with <code>INSERT JSON</code> behavior, case-sensitive column names with upper-case letters will be surrounded with double quotes.  For example, "<code>SELECT JSON myColumn FROM ...</code>" would result in a map key <code>"\"myColumn\""</code> (note the escaped quotes).</p><p>The map values will <code>JSON</code>-encoded representations (as described below) of the result set values.</p><h3 id="insertJson">INSERT JSON</h3><p>With <code>INSERT</code> statements, the new <code>JSON</code> keyword can be used to enable inserting a <code>JSON</code> encoded map as a single row.  The format of the <code>JSON</code> map should generally match that returned by a <code>SELECT JSON</code> statement on the same table.  In particular, case-sensitive column names should be surrounded with double quotes.  For example, to insert into a table with two columns named &#171;myKey&#187; and &#171;value&#187;, you would do the following:</p><pre class="sample"><pre>INSERT INTO mytable JSON '{"\"myKey\"": 0, "value": 0}'
</pre></pre><p>Any columns which are ommitted from the <code>JSON</code> map will be defaulted to a <code>NULL</code> value (which will result in a tombstone being created).</p><h3 id="jsonEncoding">JSON Encoding of Cassandra Data Types</h3><p>Where possible, Cassandra will represent and accept data types in their native <code>JSON</code> representation.  Cassandra will also accept string representations matching the CQL literal format for all single-field types.  For example, floats, ints, UUIDs, and dates can be represented by CQL literal strings.  However, compound types, such as collections, tuples, and user-defined types must be represented by native <code>JSON</code> collections (maps and lists) or a JSON-encoded string representation of the collection.</p><p>The following table describes the encodings that Cassandra will accept in <code>INSERT JSON</code> values (and <code>fromJson()</code> arguments) as well as the format Cassandra will use when returning data for <code>SELECT JSON</code> statements (and <code>fromJson()</code>):</p><table><tr><th>type    </th><th>formats accepted   </th><th>return format </th><th>notes</th></tr><tr><td><code>ascii</code>    </td><td>string                </td><td>string           </td><td>Uses JSON&#8217;s <code>\u</code> character escape</td></tr><tr><td><code>bigint</code>   </td><td>integer, string       </td><td>integer          </td><td>String must be valid 64 bit integer</td></tr><tr><td><code>blob</code>     </td><td>string                </td><td>string           </td><td>String should be 0x followed by an even number of hex digits</td></tr><tr><td><code>boolean</code>  </td><td>boolean, string       </td><td>boolean          </td><td>String must be &#171;true&#187; or "false"</td></tr><tr><td><code>date</code>     </td><td>string                </td><td>string           </td><td>Date in format <code>YYYY-MM-DD</code>, timezone UTC</td></tr><tr><td><code>decimal</code>  </td><td>integer, float, string</td><td>float            </td><td>May exceed 32 or 64-bit IEEE-754 floating point precision in client-side decoder</td></tr><tr><td><code>double</code>   </td><td>integer, float, string</td><td>float            </td><td>String must be valid integer or float</td></tr><tr><td><code>float</code>    </td><td>integer, float, string</td><td>float            </td><td>String must be valid integer or float</td></tr><tr><td><code>inet</code>     </td><td>string                </td><td>string           </td><td>IPv4 or IPv6 address</td></tr><tr><td><code>int</code>      </td><td>integer, string       </td><td>integer          </td><td>String must be valid 32 bit integer</td></tr><tr><td><code>list</code>     </td><td>list, string          </td><td>list             </td><td>Uses JSON&#8217;s native list representation</td></tr><tr><td><code>map</code>      </td><td>map, string           </td><td>map              </td><td>Uses JSON&#8217;s native map representation</td></tr><tr><td><code>smallint</code> </td><td>integer, string       </td><td>integer          </td><td>String must be valid 16 bit integer</td></tr><tr><td><code>set</code>      </td><td>list, string          </td><td>list             </td><td>Uses JSON&#8217;s native list representation</td></tr><tr><td><code>text</code>     </td><td>string                </td><td>string           </td><td>Uses JSON&#8217;s <code>\u</code> character escape</td></tr><tr><td><code>time</code>     </td><td>string                </td><td>string           </td><td>Time of day in format <code>HH-MM-SS[.fffffffff]</code></td></tr><tr><td><code>timestamp</code></td><td>integer, string       </td><td>string           </td><td>A timestamp. Strings constant are allow to input timestamps as dates, see <a href="#usingdates">Working with dates</a> below for more information.  Datestamps with format <code>YYYY-MM-DD HH:MM:SS.SSS</code> are returned.</td></tr><tr><td><code>timeuuid</code> </td><td>string                </td><td>string           </td><td>Type 1 UUID. See <a href="#constants">Constants</a> for the UUID format</td></tr><tr><td><code>tinyint</code>  </td><td>integer, string       </td><td>integer          </td><td>String must be valid 8 bit integer</td></tr><tr><td><code>tuple</code>    </td><td>list, string          </td><td>list             </td><td>Uses JSON&#8217;s native list representation</td></tr><tr><td><code>UDT</code>      </td><td>map, string           </td><td>map              </td><td>Uses JSON&#8217;s native map representation with field names as keys</td></tr><tr><td><code>uuid</code>     </td><td>string                </td><td>string           </td><td>See <a href="#constants">Constants</a> for the UUID format</td></tr><tr><td><code>varchar</code>  </td><td>string                </td><td>string           </td><td>Uses JSON&#8217;s <code>\u</code> character escape</td></tr><tr><td><code>varint</code>   </td><td>integer, string       </td><td>integer          </td><td>Variable length; may overflow 32 or 64 bit integers in client-side decoder</td></tr></table><h3 id="fromJson">The fromJson() Function</h3><p>The <code>fromJson()</code> function may be used similarly to <code>INSERT JSON</code>, but for a single column value.  It may only be used in the <code>VALUES</code> clause of an <code>INSERT</code> statement or as one of the column values in an <code>UPDATE</code>, <code>DELETE</code>, or <code>SELECT</code> statement.  For example, it cannot be used in the selection clause of a <code>SELECT</code> statement.</p><h3 id="toJson">The toJson() Function</h3><p>The <code>toJson()</code> function may be used similarly to <code>SELECT JSON</code>, but for a single column value.  It may only be used in the selection clause of a <code>SELECT</code> statement.</p><h2 id="appendixA">Appendix A: CQL Keywords</h2><p>CQL distinguishes between <em>reserved</em> and <em>non-reserved</em> keywords. Reserved keywords cannot be used as identifier, they are truly reserved for the language (but one can enclose a reserved keyword by double-quotes to use it as an identifier). Non-reserved keywords however only have a specific meaning in certain context but can used as identifer otherwise. The only <em>raison d'tre</em> of these non-reserved keywords is convenience: some keyword are non-reserved when it was always easy for the parser to decide whether they were used as keywords or not.</p><table><tr><th>Keyword      </th><th>Reserved? </th></tr><tr><td><code>ADD</code>          </td><td>yes </td></tr><tr><td><code>AGGREGATE</code>    </td><td>no  </td></tr><tr><td><code>ALL</code>          </td><td>no  </td></tr><tr><td><code>ALLOW</code>        </td><td>yes </td></tr><tr><td><code>ALTER</code>        </td><td>yes </td></tr><tr><td><code>AND</code>          </td><td>yes </td></tr><tr><td><code>APPLY</code>        </td><td>yes </td></tr><tr><td><code>AS</code>           </td><td>no  </td></tr><tr><td><code>ASC</code>          </td><td>yes </td></tr><tr><td><code>ASCII</code>        </td><td>no  </td></tr><tr><td><code>AUTHORIZE</code>    </td><td>yes </td></tr><tr><td><code>BATCH</code>        </td><td>yes </td></tr><tr><td><code>BEGIN</code>        </td><td>yes </td></tr><tr><td><code>BIGINT</code>       </td><td>no  </td></tr><tr><td><code>BLOB</code>         </td><td>no  </td></tr><tr><td><code>BOOLEAN</code>      </td><td>no  </td></tr><tr><td><code>BY</code>           </td><td>yes </td></tr><tr><td><code>CALLED</code>       </td><td>no  </td></tr><tr><td><code>CLUSTERING</code>   </td><td>no  </td></tr><tr><td><code>COLUMNFAMILY</code> </td><td>yes </td></tr><tr><td><code>COMPACT</code>      </td><td>no  </td></tr><tr><td><code>CONTAINS</code>     </td><td>no  </td></tr><tr><td><code>COUNT</code>        </td><td>no  </td></tr><tr><td><code>COUNTER</code>      </td><td>no  </td></tr><tr><td><code>CREATE</code>       </td><td>yes </td></tr><tr><td><code>CUSTOM</code>       </td><td>no  </td></tr><tr><td><code>DATE</code>         </td><td>no  </td></tr><tr><td><code>DECIMAL</code>      </td><td>no  </td></tr><tr><td><code>DELETE</code>       </td><td>yes </td></tr><tr><td><code>DESC</code>         </td><td>yes </td></tr><tr><td><code>DESCRIBE</code>     </td><td>yes </td></tr><tr><td><code>DISTINCT</code>     </td><td>no  </td></tr><tr><td><code>DOUBLE</code>       </td><td>no  </td></tr><tr><td><code>DROP</code>         </td><td>yes </td></tr><tr><td><code>ENTRIES</code>      </td><td>yes </td></tr><tr><td><code>EXECUTE</code>      </td><td>yes </td></tr><tr><td><code>EXISTS</code>       </td><td>no  </td></tr><tr><td><code>FILTERING</code>    </td><td>no  </td></tr><tr><td><code>FINALFUNC</code>    </td><td>no  </td></tr><tr><td><code>FLOAT</code>        </td><td>no  </td></tr><tr><td><code>FROM</code>         </td><td>yes </td></tr><tr><td><code>FROZEN</code>       </td><td>no  </td></tr><tr><td><code>FULL</code>         </td><td>yes </td></tr><tr><td><code>FUNCTION</code>     </td><td>no  </td></tr><tr><td><code>FUNCTIONS</code>    </td><td>no  </td></tr><tr><td><code>GRANT</code>        </td><td>yes </td></tr><tr><td><code>IF</code>           </td><td>yes </td></tr><tr><td><code>IN</code>           </td><td>yes </td></tr><tr><td><code>INDEX</code>        </td><td>yes </td></tr><tr><td><code>INET</code>         </td><td>no  </td></tr><tr><td><code>INFINITY</code>     </td><td>yes </td></tr><tr><td><code>INITCOND</code>     </td><td>no  </td></tr><tr><td><code>INPUT</code>        </td><td>no  </td></tr><tr><td><code>INSERT</code>       </td><td>yes </td></tr><tr><td><code>INT</code>          </td><td>no  </td></tr><tr><td><code>INTO</code>         </td><td>yes </td></tr><tr><td><code>JSON</code>         </td><td>no  </td></tr><tr><td><code>KEY</code>          </td><td>no  </td></tr><tr><td><code>KEYS</code>         </td><td>no  </td></tr><tr><td><code>KEYSPACE</code>     </td><td>yes </td></tr><tr><td><code>KEYSPACES</code>    </td><td>no  </td></tr><tr><td><code>LANGUAGE</code>     </td><td>no  </td></tr><tr><td><code>LIMIT</code>        </td><td>yes </td></tr><tr><td><code>LIST</code>         </td><td>no  </td></tr><tr><td><code>LOGIN</code>        </td><td>no  </td></tr><tr><td><code>MAP</code>          </td><td>no  </td></tr><tr><td><code>MODIFY</code>       </td><td>yes </td></tr><tr><td><code>NAN</code>          </td><td>yes </td></tr><tr><td><code>NOLOGIN</code>      </td><td>no  </td></tr><tr><td><code>NORECURSIVE</code>  </td><td>yes </td></tr><tr><td><code>NOSUPERUSER</code>  </td><td>no  </td></tr><tr><td><code>NOT</code>          </td><td>yes </td></tr><tr><td><code>NULL</code>         </td><td>yes </td></tr><tr><td><code>OF</code>           </td><td>yes </td></tr><tr><td><code>ON</code>           </td><td>yes </td></tr><tr><td><code>OPTIONS</code>      </td><td>no  </td></tr><tr><td><code>OR</code>           </td><td>yes </td></tr><tr><td><code>ORDER</code>        </td><td>yes </td></tr><tr><td><code>PASSWORD</code>     </td><td>no  </td></tr><tr><td><code>PERMISSION</code>   </td><td>no  </td></tr><tr><td><code>PERMISSIONS</code>  </td><td>no  </td></tr><tr><td><code>PRIMARY</code>      </td><td>yes </td></tr><tr><td><code>RENAME</code>       </td><td>yes </td></tr><tr><td><code>REPLACE</code>      </td><td>yes </td></tr><tr><td><code>RETURNS</code>      </td><td>no  </td></tr><tr><td><code>REVOKE</code>       </td><td>yes </td></tr><tr><td><code>ROLE</code>         </td><td>no  </td></tr><tr><td><code>ROLES</code>        </td><td>no  </td></tr><tr><td><code>SCHEMA</code>       </td><td>yes </td></tr><tr><td><code>SELECT</code>       </td><td>yes </td></tr><tr><td><code>SET</code>          </td><td>yes </td></tr><tr><td><code>SFUNC</code>        </td><td>no  </td></tr><tr><td><code>SMALLINT</code>     </td><td>no  </td></tr><tr><td><code>STATIC</code>       </td><td>no  </td></tr><tr><td><code>STORAGE</code>      </td><td>no  </td></tr><tr><td><code>STYPE</code>        </td><td>no  </td></tr><tr><td><code>SUPERUSER</code>    </td><td>no  </td></tr><tr><td><code>TABLE</code>        </td><td>yes </td></tr><tr><td><code>TEXT</code>         </td><td>no  </td></tr><tr><td><code>TIME</code>         </td><td>no  </td></tr><tr><td><code>TIMESTAMP</code>    </td><td>no  </td></tr><tr><td><code>TIMEUUID</code>     </td><td>no  </td></tr><tr><td><code>TINYINT</code>      </td><td>no  </td></tr><tr><td><code>TO</code>           </td><td>yes </td></tr><tr><td><code>TOKEN</code>        </td><td>yes </td></tr><tr><td><code>TRIGGER</code>      </td><td>no  </td></tr><tr><td><code>TRUNCATE</code>     </td><td>yes </td></tr><tr><td><code>TTL</code>          </td><td>no  </td></tr><tr><td><code>TUPLE</code>        </td><td>no  </td></tr><tr><td><code>TYPE</code>         </td><td>no  </td></tr><tr><td><code>UNLOGGED</code>     </td><td>yes </td></tr><tr><td><code>UPDATE</code>       </td><td>yes </td></tr><tr><td><code>USE</code>          </td><td>yes </td></tr><tr><td><code>USER</code>         </td><td>no  </td></tr><tr><td><code>USERS</code>        </td><td>no  </td></tr><tr><td><code>USING</code>        </td><td>yes </td></tr><tr><td><code>UUID</code>         </td><td>no  </td></tr><tr><td><code>VALUES</code>       </td><td>no  </td></tr><tr><td><code>VARCHAR</code>      </td><td>no  </td></tr><tr><td><code>VARINT</code>       </td><td>no  </td></tr><tr><td><code>WHERE</code>        </td><td>yes </td></tr><tr><td><code>WITH</code>         </td><td>yes </td></tr><tr><td><code>WRITETIME</code>    </td><td>no  </td></tr></table><h2 id="appendixB">Appendix B: CQL Reserved Types</h2><p>The following type names are not currently used by CQL, but are reserved for potential future use.  User-defined types may not use reserved type names as their name.</p><table><tr><th>type      </th></tr><tr><td><code>bitstring</code> </td></tr><tr><td><code>byte</code>      </td></tr><tr><td><code>complex</code>   </td></tr><tr><td><code>date</code>      </td></tr><tr><td><code>enum</code>      </td></tr><tr><td><code>interval</code>  </td></tr><tr><td><code>macaddr</code>   </td></tr></table><h2 id="changes">Changes</h2><p>The following describes the changes in each version of CQL.</p><h3 id="a3.4.0">3.4.0</h3><ul><li>Support for <a href="#createMVStmt">materialized views</a></li><li><a href="#deleteStmt"><code>DELETE</code></a> support for inequality expressions and <code>IN</code> restrictions on any primary key columns</li><li><a href="#updateStmt"><code>UPDATE</code></a> support for <code>IN</code> restrictions on any primary key columns</li></ul><h3 id="a3.3.1">3.3.1</h3><ul><li>The syntax <code>TRUNCATE TABLE X</code> is now accepted as an alias for <code>TRUNCATE X</code></li></ul><h3 id="a3.3.0">3.3.0</h3><ul><li>Adds new <a href="#aggregates">aggregates</a></li><li>User-defined functions are now supported through <a href="#createFunctionStmt"><code>CREATE FUNCTION</code></a> and <a href="#dropFunctionStmt"><code>DROP FUNCTION</code></a>.</li><li>User-defined aggregates are now supported through <a href="#createAggregateStmt"><code>CREATE AGGREGATE</code></a> and <a href="#dropAggregateStmt"><code>DROP AGGREGATE</code></a>.</li><li>Allows double-dollar enclosed strings literals as an alternative to single-quote enclosed strings.</li><li>Introduces Roles to supercede user based authentication and access control</li><li><a href="#usingdates"><code>Date</code></a> and <a href="usingtime"><code>Time</code></a> data types have been added</li><li><a href="#json"><code>JSON</code></a> support has been added</li><li><code>Tinyint</code> and <code>Smallint</code> data types have been added</li><li>Adds new time conversion functions and deprecate <code>dateOf</code> and <code>unixTimestampOf</code>. See <a href="#timeFun"><code>Time conversion functions</code></a></li></ul><h3 id="a3.2.0">3.2.0</h3><ul><li>User-defined types are now supported through <a href="#createTypeStmt"><code>CREATE TYPE</code></a>, <a href="#alterTypeStmt"><code>ALTER TYPE</code></a>, and <a href="#dropTypeStmt"><code>DROP TYPE</code></a></li><li><a href="#createIndexStmt"><code>CREATE INDEX</code></a> now supports indexing collection columns, including indexing the keys of map collections through the <code>keys()</code> function</li><li>Indexes on collections may be queried using the new <code>CONTAINS</code> and <code>CONTAINS KEY</code> operators</li><li>Tuple types were added to hold fixed-length sets of typed positional fields (see the section on <a href="#types">types</a> )</li><li><a href="#dropIndexStmt"><code>DROP INDEX</code></a> now supports optionally specifying a keyspace</li></ul><h3 id="a3.1.7">3.1.7</h3><ul><li><code>SELECT</code> statements now support selecting multiple rows in a single partition using an <code>IN</code> clause on combinations of clustering columns.  See <a href="#selectWhere">SELECT WHERE</a> clauses.</li><li><code>IF NOT EXISTS</code> and <code>IF EXISTS</code> syntax is now supported by <code>CREATE USER</code> and <code>DROP USER</code> statmenets, respectively.</li></ul><h3 id="a3.1.6">3.1.6</h3><ul><li>A new <a href="#uuidFun"><code>uuid</code> method</a> has been added.</li><li>Support for <code>DELETE ... IF EXISTS</code> syntax.</li></ul><h3 id="a3.1.5">3.1.5</h3><ul><li>It is now possible to group clustering columns in a relatiion, see <a href="#selectWhere">SELECT WHERE</a> clauses.</li><li>Added support for <code>STATIC</code> columns, see <a href="#createTableStatic">static in CREATE TABLE</a>.</li></ul><h3 id="a3.1.4">3.1.4</h3><ul><li><code>CREATE INDEX</code> now allows specifying options when creating CUSTOM indexes (see <a href="#createIndexStmt">CREATE INDEX reference</a> ).</li></ul><h3 id="a3.1.3">3.1.3</h3><ul><li>Millisecond precision formats have been added to the timestamp parser (see <a href="#usingtimestamps">working with dates</a> ).</li></ul><h3 id="a3.1.2">3.1.2</h3><ul><li><code>NaN</code> and <code>Infinity</code> has been added as valid float contants. They are now reserved keywords. In the unlikely case you we using them as a column identifier (or keyspace/table one), you will noew need to double quote them (see <a href="#identifiers">quote identifiers</a> ).</li></ul><h3 id="a3.1.1">3.1.1</h3><ul><li><code>SELECT</code> statement now allows listing the partition keys (using the <code>DISTINCT</code> modifier). See <a href="https://issues.apache.org/jira/browse/CASSANDRA-4536">CASSANDRA-4536</a>.</li><li>The syntax <code>c IN ?</code> is now supported in <code>WHERE</code> clauses. In that case, the value expected for the bind variable will be a list of whatever type <code>c</code> is.</li><li>It is now possible to use named bind variables (using <code>:name</code> instead of <code>?</code>).</li></ul><h3 id="a3.1.0">3.1.0</h3><ul><li><a href="#alterTableStmt">ALTER TABLE</a> <code>DROP</code> option has been reenabled for CQL3 tables and has new semantics now: the space formerly used by dropped columns will now be eventually reclaimed (post-compaction). You should not readd previously dropped columns unless you use timestamps with microsecond precision (see <a href="https://issues.apache.org/jira/browse/CASSANDRA-3919">CASSANDRA-3919</a> for more details).</li><li><code>SELECT</code> statement now supports aliases in select clause. Aliases in WHERE and ORDER BY clauses are not supported. See the <a href="#selectStmt">section on select</a> for details.</li><li><code>CREATE</code> statements for <code>KEYSPACE</code>, <code>TABLE</code> and <code>INDEX</code> now supports an <code>IF NOT EXISTS</code> condition. Similarly, <code>DROP</code> statements support a <code>IF EXISTS</code> condition.</li><li><code>INSERT</code> statements optionally supports a <code>IF NOT EXISTS</code> condition and <code>UPDATE</code> supports <code>IF</code> conditions.</li></ul><h3 id="a3.0.5">3.0.5</h3><ul><li><code>SELECT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements now allow empty <code>IN</code> relations (see <a href="https://issues.apache.org/jira/browse/CASSANDRA-5626">CASSANDRA-5626</a>).</li></ul><h3 id="a3.0.4">3.0.4</h3><ul><li>Updated the syntax for custom <a href="#createIndexStmt">secondary indexes</a>.</li><li>Non-equal condition on the partition key are now never supported, even for ordering partitioner as this was not correct (the order was <strong>not</strong> the one of the type of the partition key). Instead, the <code>token</code> method should always be used for range queries on the partition key (see <a href="#selectWhere">WHERE clauses</a> ).</li></ul><h3 id="a3.0.3">3.0.3</h3><ul><li>Support for custom <a href="#createIndexStmt">secondary indexes</a> has been added.</li></ul><h3 id="a3.0.2">3.0.2</h3><ul><li>Type validation for the <a href="#constants">constants</a> has been fixed. For instance, the implementation used to allow <code>'2'</code> as a valid value for an <code>int</code> column (interpreting it has the equivalent of <code>2</code>), or <code>42</code> as a valid <code>blob</code> value (in which case <code>42</code> was interpreted as an hexadecimal representation of the blob). This is no longer the case, type validation of constants is now more strict. See the <a href="#types">data types</a> section for details on which constant is allowed for which type.</li><li>The type validation fixed of the previous point has lead to the introduction of <a href="#constants">blobs constants</a> to allow inputing blobs. Do note that while inputing blobs as strings constant is still supported by this version (to allow smoother transition to blob constant), it is now deprecated (in particular the <a href="#types">data types</a> section does not list strings constants as valid blobs) and will be removed by a future version. If you were using strings as blobs, you should thus update your client code ASAP to switch blob constants.</li><li>A number of functions to convert native types to blobs have also been introduced. Furthermore the token function is now also allowed in select clauses. See the <a href="#functions">section on functions</a> for details.</li></ul><h3 id="a3.0.1">3.0.1</h3><ul><li><a href="#usingtimestamps">Date strings</a> (and timestamps) are no longer accepted as valid <code>timeuuid</code> values. Doing so was a bug in the sense that date string are not valid <code>timeuuid</code>, and it was thus resulting in <a href="https://issues.apache.org/jira/browse/CASSANDRA-4936">confusing behaviors</a>.  However, the following new methods have been added to help working with <code>timeuuid</code>: <code>now</code>, <code>minTimeuuid</code>, <code>maxTimeuuid</code> , <code>dateOf</code> and <code>unixTimestampOf</code>. See the <a href="#timeuuidFun">section dedicated to these methods</a> for more detail.</li><li>&#171;Float constants&#187;#constants now support the exponent notation. In other words, <code>4.2E10</code> is now a valid floating point value.</li></ul><h2 id="Versioning">Versioning</h2><p>Versioning of the CQL language adheres to the <a href="http://semver.org">Semantic Versioning</a> guidelines. Versions take the form X.Y.Z where X, Y, and Z are integer values representing major, minor, and patch level respectively. There is no correlation between Cassandra release versions and the CQL language version.</p><table><tr><th>version</th><th>description</th></tr><tr><td>Major     </td><td>The major version <em>must</em> be bumped when backward incompatible changes are introduced. This should rarely occur.</td></tr><tr><td>Minor     </td><td>Minor version increments occur when new, but backward compatible, functionality is introduced.</td></tr><tr><td>Patch     </td><td>The patch version is incremented when bugs are fixed.</td></tr></table></body></html>